\begin{itemize}	
	\item{Validation - cyclic graph - multiple dependencies}
	\item{subgraph subform dependencies}
	\item{Descriptor for data and processing}
\end{itemize}

\chapter{Framework functionality} \label{5}


The aim of this chapter is to present the main mechanisms of the implemented software framework, which is capable of operating on high-level configuration data. Section \ref{51} contains a more abstract description of the functionality, while section \ref{52} goes into the implementation details both of the server and client side programming, including how the framework can be integrated into the applied web application. In both sections the explanation refers to the examples discussed in the previous chapter.


\section{Main software modules and tasks} \label{51}


In \figref{332_1} we have seen the main work flow and components of the framework. \figref{scheme_1} is in turn a more detailed depiction of the software modules and processes of the application.


\img{\V}{scheme_1.png}{More detailed scheme}{scheme_1}


This section is divided into three subsections. First is the part (section \ref{511}) discusses the  processing of the configuration data and generation of the functionality descriptor objects for the client and the server. The second part (section \ref{512}) is about the client functionality including the asynchronous communication with the server. Finally the third (section \ref{513}) part covers the process after the submission, namely how the RDF data is generated based on the data coming from the client, as well as how the existing data is retrieved from the triples store.


\subsection{Validation} \label{511}


The processor algorithm has four main tasks to solve. The validation of the configuration data, generation of the form descriptor JSON object, and the Java object for data dependencies and for  the graph model. 


\img{\V}{processor_tasks.png}{Processor tasks}{processor_tasks}


The input of the algorithm is the set of triples describing the data model with its constraints, and form model, which refers to the nodes in the triple set. The first task to do is the validation because the descriptors are not supposed to be generated based on incorrect configuration data. The validator process has three scope of the checking, the nodes, the graph and the form.
 
\figref{valid_1} depicts an example data model and illustrates the cases of valid and invalid nodes (\figref{graph_notation} contains the meaning of the shapes and colors). The explanation starts with the discussion of the form input nodes. Node \textit{2} is valid because it is possible to generate a SPARQL query that retrieves the possible values of it. The query contains one triple which ask the subclasses of the constant class. Furthermore node \textit{4} is valid as well, because there is path to it from a valid class node, therefore for there is again a SPARQL query for its values. However the variable \textit{3} is not valid, because it does not contribute to any triple in path with valid input node or constant. Here it is important to note that the path cannot come from the instance to the class, just the other way around. So the path 2 --> 1 --> 4 counts in the processor routine, but 2 --> 5 --> 6 --> 3 does not.
  
\img{\V}{valid_1.png}{Valid and invalid nodes}{valid_1}


The next task regarding the nodes is to check if each has a value by the RDF triple creation. The instances coming from the interface are automatically valid, because their URI is an input value. But the ones that have to generated newly and get as value a new unused URI from the triple store, must constribute to triple as subject, where the predicate is \textit{rdf:type} and the object is a valid class. For this reason the node \textit{5} is valid, since its type class is valid, but node \textit{6} is not. Moreover node \textit{7} is not valid as well, since it does not have any type class defined in the data model. Finally regarding the literals the validation is the simplest, either they appear on the form or have constant value, otherwise they are invalid. 


\img{\V}{valid_2.png}{Valid and invalid graph}{valid_2}


Above the nodes important itself the whole graph built by the triples have to be investigated. In the previous chapter the triple type \textit{MultiTriple} were introduced. The rule regarding this type of triple that it divides the graph into subgraphs, and the subgraphs can connect to each other only be these triples. \figref{valid_2} illustrates the valid and invalid graph arrangements. The reason is that only to this type of scheme can the JSON object of the created by the data input process be mapped.



\subsection{Dependencies and form descriptor generation}  \label{512}


The previous section outlined the rules of the data model. This and the following section although discusses the scheme of the object and the main principles of how the client and the server operates upon it. 
The use-cases of the previous chapter showed that input nodes of the form are dependent from the main input nodes and from each other as well. The task is to infer from the graph model the variable dependencies, that is build by the triples of the participant. Each variable dependency consists of the set of input nodes and triples, and one output node. 

Important that form elements on the form has a specific order, and the rule is that a node cannot be dependent on an other node which comes in the form after it, because its value is not available at the moment when the options for the node before it has to be loaded, thus it cannot contribute to the SPARQL query with its value. However each node is dependent on the main input nodes, because their value is given before the form loading.


\img{\V}{dependency.png}{Skeletal inventory data constraints}{dependency}


\figref{dependency} show the constraint of the problem of the skeletal inventories. In this case there are two main inputs, the \textit{subjectUri} and the \textit{rangeUri} and there form nodes.
The first task is to get the graph path that with the inputs for each variable. The process starts with the first node (\textit{subSubdivision}). The rule is that algorithm start to discover the graph starting from the node in scope, and stops if find a node which is a smaller input of it. So for varible denoted with one, the dependecy contains all the triples from the figure because only the main input nodes are available by the loading of the form. But for variable 2 (\textit{boneOrgan}) the value of variable 1 is available, therefore it dependencies has 

\img{\V}{dependencyResult.png}{Form dependencies}{dependency}



\subsection{Graph model generation}  \label{513}


\begin{itemize}	
	\item{Graph model}
	\item{New instances}
	\item{Delete}
	\item{Existing data loading}
\end{itemize}


\section{Implementation} \label{52}


This request arrives to the server and based on the parameter \textit{predicateUri} the application finds the configuration triples. More details about how this parameter value is assigned to the configuration setting will be provided in the next chapter.

As it was described in the previous chapter the whole process starts from the pages for data display with the HTTP requests initiated by the links of the data fields. 



\subsection{Server side} 

\begin{itemize}
	\item This section introduces how application on the server is able to operate based on data queried from the configuration dataset
	
\end{itemize}

\subsubsection{Overview}

\begin{itemize}
	\item The following image shows the most important steps of the data input process
\end{itemize}

\imgK{\IVII}{overview.png}{Overview of the mechanism on the server}


\subsubsection{Form representation in Java}

\imgK{\IVII}{uml1.png}{UML Diagram of the classes for the form}

\begin{itemize}
	\item The literal fields asks for the type of the variable it represents and the type of the descriptor will be based on this literal field.
\end{itemize}


\imgK{\IVII}{formDescriptor.png}{Form descriptor JSON object}

\subsubsection{Data model in Java}


\begin{itemize}
	\item Querying the configuration triples regarding statements
	\item Processing into the tree structured graph model
\end{itemize}


\imgK{\IVII}{graphUML.png}{Graph UML}

Validation:

\begin{itemize}
	\item Data dependencies can be over graphs
	\item But graphs can be connected only through multi statements
	\item The graph has to be a tree. There are no use cases right now where any loop would be required
\end{itemize}

\imgK{\IVII}{jsonVSGraph.png}{JSON vs graph model}

\begin{itemize}
	\item Data saving mechanism explanation
	\item Data retrieval mechanism explanation
\end{itemize}

\subsubsection{Data Dependencies}


\begin{itemize}
	\item The data dependencies are important only for the form. 
	\item Everything starts with the form descriptor.
	\item There are cases where from the main form no element appears on the form.
	\item A have to bring examples to some problems that illustrate the problem.
	\item Here comes at first the ontology awareness into question....
\end{itemize}


\imgK{\IVII}{exampleProblem.png}{Example problem}

where,

\imgK{\IVII}{explanation.png}{Elements of the simplified notation}

\imgK{\IVII}{restrictionDirection.png}{Two restriction directions}

\begin{itemize}
	\item Post processing for different restriction types
\end{itemize}


\imgK{\IVII}{variableDependency.png}{Getting dependent data}

\subsubsection{Editing and deleting data}

\begin{itemize}
	\item This feature was not introduced on the overview image but it is really important.
\end{itemize}


\imgK{\IVII}{edit.png}{Difference between the submissions and edit data on the form}


\subsection{Client side}

\begin{itemize}
	\item In this chapter it is discussed how the forms are implemented in JavaScript
	\item Each subsection contains code examples that gradually introduce the functionalities
	\item Codes are mostly simplified to facilitate the understanding		
\end{itemize}


\subsubsection{Object oriented JavaScript}

\begin{itemize}
	\item The task of code in on the interface is to operate based on a configuration data dynamically.
	\item There two subtasks, the generation of the UI elements (i.e input fields, buttons, etc.) and manage the data input and display on the form
	\item To solve these problem, an object oriented approach is applied
	\item This means that there are classes that handles both the UI and the data related tasks
	\item See an example for the class definition in JS
\end{itemize}


\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={JavaScript class}, captionpos=b]
class StringField {
constructor(...){
this.container = $("<div/>")
...
}
someMethod(){...}			
}
\end{lstlisting}

\begin{itemize}
	\item Each form elements are represented by such objects, and the form loading based on the descriptor runs by the initialisation of these elements.  
\end{itemize}

\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={Form generation based on configuration data}, captionpos=b]
var formData = new Object()
for(var i = 0, i < formElements.length; i++){
var descriptor = formElements[i]
var element = null
switch(descriptor.type){
case "stringField":
element = new StringField(descriptor, formData)
break;
case "..." : 
}
$("#formContainer").append(element.container)
}	
\end{lstlisting}


%\imgK{\IVIII}{1_1_oopJS.png}{UML Class diagram for the JS implementation}
%\imgK{\IVIII}{1_2_layoutOfClasses.png}{DOM Elements of the classes}

\begin{itemize}
	\item Explanation of the code ...
	\item This is the way how it is possible to generate interfaces
\end{itemize}


\subsubsection{Handling data}

\begin{itemize}
	\item Above the element generation for the different forms it is necessary to handle of course the data based on the descriptor
	\item Each form element's descriptor contains a field called dataKey. The value of this field will be the key of data in the form data object.
\end{itemize}


\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={Data saving}, captionpos=b]
class StringField {
constructor(descriptor, formData){
this.descriptor = descritor
this.formData = formData
this.inputField = $("<input/>").change(this.handler)
}

handler(){
this.formData[this.descriptor.dataKey]=this.inputField.val() 
}			
}
\end{lstlisting}



\begin{itemize}
	\item The previous code illustrates how the form element object set the global form data field based on configuration data
	\item Further details about the code...
\end{itemize}

\begin{itemize}
	\item Handling existing data
	\item It can be the case that form is loaded for editing. Then in this case the formData variable coming as input to the constructor contains the value for the dataKey? 
\end{itemize}

\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={Data saving}, captionpos=b]
class StringField {
constructor(descriptor, formData){
if(formData[descriptor.dataKey] != undefined){
this.editMode = true
}
}

handler(){
if(this.editMode){
var oldValue = this.formData[this.descriptor.dataKey]
var newValue = this.inputField.val() 
}
AJAX.updateField(oldValue, newValue)
}			
}
\end{lstlisting}


\subsubsection{Sub form adders}


\begin{itemize}
	\item Descriptor of the sub form adder contains a field called subform
	\item Then the initialisation of the form happend through the Form class.	
	\item This is used by the initial form loading as well
\end{itemize}

\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={Sub form adder routine}, captionpos=b]
class SubformAdder {
constructor(descriptor, formData){
...
this.addButton = $("<div/>").text("Add").click(this.add)    
this.subFormDescriptor = this.descriptor.subForm
this.formData[this.descriptor.dataKey] = []
}

add(){
var subformDataObject = new Object()
this.formData[this.descriptor.dataKey].
push(subFormDataObject) 
this.subFormContainer.append(
new Form(this.subFormDescriptor, subFormDataObject))
}
}
\end{lstlisting}

\begin{itemize}
	\item Important for each subform a new JSON object is generated which is pushed to the array		
	\item The same way the subform adder checks if the this.formData[this.descriptor.dataKey] contains already existing data and adds them if they are there
\end{itemize}

\subsection{Data dependency}

\subsection{Form validation}
