
\chapter{Framework functionality} \label{5}

The aim of this chapter is to present the main mechanisms of the implemented software framework, which is capable of operating on a high-level configuration data. Section \ref{51} contains a more abstract description of the functionality, while section \ref{52} goes into the implementation details both on the server and client side programming, including how the framework can be integrated into the applied VIVO framework. In both sections, the explanations mostly refer to the use-cases discussed in the previous chapter.

\section{Main software modules and tasks} \label{51}

On \figref{scheme_1} the workflow and the main components of the framework can be seen. After the initial form request, an algorithm processes the configuration data and generates form, dependency and graph objects for the client and the server.

\img{\V}{scheme_1.png}{More detailed scheme}{scheme_1}

This section is split into three subsections. The first (section \ref{511}) discusses the processing of the configuration data and the generation of the functionality descriptor objects. The second part (section \ref{512}) is about the client functionality including the asynchronous communication with the server. Finally, the third (section \ref{513}) part covers the process after the submission, namely how the RDF data is generated based on the data coming from the client, as well as how the existing form data is retrieved from the triple store for editing.

\subsection{Validation} \label{511}

The processor algorithm has four main tasks to solve. The validation of the configuration data, the generation of the form descriptor JSON object, and the Java objects for the data dependencies and the graph model. 

\img{\V}{processor_tasks.png}{Processor tasks}{processor_tasks}

The input of the algorithm is a set of triples describing the data model with its constraints, and the form model, which refers to the nodes in the triple set. The first task to do is the validation because the descriptors are not supposed to be generated based on incorrect configuration data. The validator process has two scopes of the checking, the nodes themselves and the graph structure built by the triples.
 
\figref{valid_1} depicts an example data model and illustrates some cases of valid and invalid nodes. The red nodes are coming as input, and the green stands for a constant. The explanation starts with the discussion of class nodes (ellipses). Node 2 is valid because it is possible to generate a SPARQL query that retrieves the possible values of it for the form. The query contains one triple which asks the subclasses of the constant class. Furthermore, node 1 is valid as well, because there is path to it from a valid class node, therefore there is again a SPARQL query for its values after the submission. However, node 3 is not valid because it does not contribute to any path with valid input node or constant. Here it is important to note that the path cannot come from the instance to the class, just the other way around. So the path 2 --> 1 --> 4 counts in the processor routine, but path 2 --> 5 --> 6 --> 3 does not.

\img{\V}{valid_1.png}{Valid and invalid nodes}{valid_1}

The next task above the classes is to check if each instance (rectangles) has a value or type by the RDF triple creation. The instances coming from the interface are automatically valid because their URI is an input value. But the ones that have to be generated newly and get a new unused URI as value must contribute to a triple as subject, where the predicate is \textit{rdf:type} and the object is a valid class. Consequently, node 5 is valid since its type class is valid, but node 6 is not. Finally, node 7 is not valid, since it does not have any type class defined for it.

\img{\V}{valid_2.png}{Valid and invalid graph}{valid_2}

Above the nodes, the whole graph itself have to be investigated too. In the previous chapter, the triple type \textit{MultiTriple} (double line on the figure) were introduced. The rule regarding this type of triple that it divides the whole graph into subgraphs and the subgraphs are allowed to be connected to each other only by these triples. The reason is that only to this hierarchical graph scheme can the form JSON object be mapped.  \figref{valid_2} illustrates the valid and invalid graph arrangements.

\subsection{Dependencies and form functionality}  \label{512}

The set of triples describing the data model builds a graph where the different input nodes are connected to each other. A further task of the processor algorithm is to determine the subgraphs that define the SPARQL queries for the nodes appearing on the form. The elements on the form have a specified order and a variable can be dependent only of the main input nodes, or of such nodes that are before them on the form.

\img{\V}{form.png}{Form element order}{form}

\figref{form} shows a simplified form layout for skeletal inventories and emphasizes the order of the elements with a number. The node \textit{subSubdivision} can only be dependent of the main input nodes because it is the first form one. However, the node \textit{boneOrgan} in turn can be dependent on the \textit{subSubDivision} as well, because its value has to be set before the selector options in the subform are loaded.

\img{\V}{skeletalInventory.png}{Skeletal inventory data constraints}{skeletalInventory}

To exemplify the dependency generator algorithm \figref{skeletalInventory} depicts the restriction triples of the skeletal inventory use-case. The task is to get one or more paths to particular form variables, where the start nodes or the path are main input nodes or former form node. As the form's first element refers to the node \textit{subSubDivision} its dependency has to be evaluated first. Since the node \textit{subSubDivision} contributes to two restriction triples in the data scheme it is necessary to check the both paths. Since this node cannot be dependent on any other form node, it is dependent on the two main input nodes (\textit{subjectUri} and \textit{rangeUri}). For the node \textit{boneOrgan}, the \textit{subjectUri} will be the input of the left path again, but on the right path the algorithm terminates by the \textit{subSubdivison} variable. \figref{dependency} shows the results subgraphs of the algorithm, where the output is depicted with green and the inputs with red and light-red respectively.

\img{\V}{dependencyResult.png}{Form dependency subgraphs}{dependency}

The result of the processing is important both for the descriptor of the client and the server. On the server, the dependencies are saved using such classes that have the necessary fields for the paths, and for the output and input nodes. The initialized dependency descriptor objects are collected in a data map, where the key is the variable name of the output node. For the client, the dependency descriptor is a JSON object that contains which form node is an input for the individual variables in an array. The task of the form by loading new subform is to check this array and get the variables required values from the form.

\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={Dependency descriptor JSON for skeletal inventories}, captionpos=b, belowskip=1em, aboveskip=2em]
var dependencies = {
	subSubDivision : [],
	boneOrgan : ["subSubDivision"]
}
\end{lstlisting}
 
Above the dependency the descriptor the JavaScript framework obtains the layout descriptor JSON for the form elements upon which it can generate the form. The mechanism of the form descriptor generation a quite simple because it is practically the conversion of a Java object into a JSON object. The fields of the Java object appear in the JSON objects as key. All individual Java class representing a form element has its type field value keyword (i.e "literalField" or "subFormAdder"). Based on this value can the form generator algorithm call the appropriate JavaScript class.

\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={Java to JSON}, captionpos=b, belowskip=1em, aboveskip=2em]
public JSONObject getDescriptor(){
	JSONObject object = new JSONObject();
	object.put("title", this.title)
	object.put("type", this.type)
	... 
	return object;	
}
\end{lstlisting}

Moreover, if the form element is sub form adder then it has a field \textit{subForm}, which comes well of course into the descriptor, and this is the way how the multi-level JSON object is created.

\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={Subform descriptor}, captionpos=b, belowskip=1em, aboveskip=2em]
	object.put("subForm", this.subForm.getDescriptor());
\end{lstlisting}

\figref{formDescriptor} illustrates a generated JSON object for a form with the data dependencies too.

\img{\V}{formDescriptor.png}{Form descriptor JSON}{formDescriptor}

\subsection{Graph model generation}  \label{513}

The previous section outlined how the set of Java objects are converted into the form descriptor JSON object, and into Java objects describing the variable dependencies for the AJAX requests. A further task of the framework is to receive the submitted multi-level JSON object coming from the client and generate the appropriate set of RDF triples. So in order to prepare the server for the reception of the form data, the same object structure have to be generated, which is coming from the form. We have seen in the previous chapters, that the form data object has the same scheme as the form has, and the form follows the scheme defined by the multi triples in the triple set. Therefore the task of the last part of the processor algorithm is to decompose the set of triples by multi triples into graphs. The graph structure is represented in the server by a Java class called \textit{Graph}.

\img{\V}{graphModel.png}{Conversion from triples into graph model}{graphModel}

The decomposition starts by the initial RDF node, which defines the main graph. The class \textit{Graph} has a Map<String, Graph> field where the subgraphs are stored. The keys of the map are equivalent to the keys of the keys of the arrays in the incoming JSON object. The other keys of the JSON are the variables of the corresponding graph. The following code snippet shows the basics of the RDF data generation from multi-level JSON object. 

\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={Saving routine in Java}, label=dataGeneration captionpos=b, belowskip=1em, aboveskip=2em]
saveData(JSONObject formData){
	this.save(formData);
	for(String keys : this.subGraphs.keys()){
		JSONArray array = formData.get(key);
		Graph subGraph = this.subGraphs.get(key);
		subGraph.saveArray(array)					
	}
}
\end{lstlisting}

The save routine creates the RDF triples of the graph based on the data fields of the JSON object. The loop iterates through the subgraphs of the graph and gets the arrays with the same key from the JSON and passes it to the corresponding subgraphs, that perform the same algorithm as many times, as many elements of the input array have. This is the way how the multi-dimensional JSON is processed by the same structure of graph model on the server.

\figurename{graphProcess} illustrates the process of the JSON-RDF conversion by means of graph model. The advantage of this graph model that it can be applied the same way for the data retrieval, where the graph performs the SPARQL queries based on its triples, and generates the arrays of objects from the result table. 

\img{\V}{graphProcess.png}{JSON/RDF through the graph model}{graphProcess}

\newpage
\section{Implementation} \label{52}

The description of the implementation starts with the client side because it is more independent from the other parts, and it sufficient to understand the functionality of the server accurately.

\subsection{Client side}

This subsection presents the basics of the JavaScript implementation that realizes the dynamic form generation and event handling based on JSON form configuration data. The first part covers the creation of a form itself, and how the data is set to form data object, while the second part is about how the form enables multi-dimensional data input by means of subform adders.
 
\subsubsection{Form loading}

In contrast to Java, JavaScript codes are not necessarily built up in an object-oriented manner. On pages where the elements are statically defined in HTML, it is sufficient to assign event handler routines to them. However in our case, none of the elements of the page is coded into HTML, but everything is dynamic and thus added by JavaScript. In the implementation, the JavaScript classes are applied, whose input is the descriptor object, based on which they generate the corresponding data input fields, and handles the data entered through them by the user. In this section the functionality of the two main classes, the \textit{Form} and \textit{Formelement} is discussed. 

\img{\V}{JS_form_formElement.png}{Form and form element JavaScript classes}{JS_form_element}

\figref{JS_form_element} illustrate the structure of the two main classes. The most fundamental difference between these JavaScript classes to Java classes, that they do not contain only fields and routines (or methods) but eventually UI elements as well. The UI elements can represent and HTML tag and can be added or removed any time by the routines. Each class of the implemented JavaScript library has a defined set of UI elements. 

The form generation process begins with the initialization of a \textit{Form} object, where the constructor (like in Java) gets the descriptor JSON object coming from the server. As it was described in the previous chapter, the descriptor contains a list of the form element descriptor objects. The \textit{loadFormElements()} routine iterates through on this array, and initiates the form element objects.

\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={Form generation based on configuration data}, label=formGen captionpos=b, belowskip=1em, aboveskip=2em]
var formData = new Object()
for(var i = 0, i < formElements.length; i++){
	switch(formElements[i].type){
		case "literalField":
			var element = new LiteralField(formElements[i], formData)
			break;
		case "selector" :  ...
	}
	this.elements.append(element.container)
}	
\end{lstlisting}


Each form element type is represented as subclass of the \textit{formElement} class. They all have a container UI field, which contains their title and input field HTML element. This container field is added to the \textit{elements} field of the \textit{Form} object.

Listing \ref{formElement} show a small cut from the code of the LiteralField, which is the subclass of the \textit{FormElement} class. The field \textit{inputField} is the HTML <input/> tag, and if its value changes then the \textit{editHandler} routine is called. The editHandler is the function that realizes the dynamic form data creation, by setting the value of the input field into the form data object with the key defined in its the descriptor. The key is stored in the \textit{dataKey} field of the descriptor, which is the variable name of the RDFNode the input element represents.

\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={Form element}, label=formElement, captionpos=b, belowskip=1em, aboveskip=2em]
class LiteralField extends FormElement{
	constructor(descriptor, formData){
		super(descriptor, formData)
		this.inputField = $("<input/>").type("text").change(this.editHandler)
		...
	}
	editHandler(){
		this.formData[this.descriptor.dataKey]=this.inputField.val() 
	}			
}
\end{lstlisting}

This is the fundamental mechanism of how object-oriented JavaScript can be employed to generate forms and put the entered values into JSON object based on configuration data.

\subsubsection{Sub forms}

The previous section explained how the form algorithm creates the JSON object of the form data. This section extends the explanation of how it is possible to add the multi level data by sub form adders. To this two new JavaScript class functionality is outline, the \textit{SubFormAdder} and the \textit{SubForm}. The former is the subclass of the \textit{FormElement} and the latter of the \textit{Form} class. 

\img{\V}{JS_subFormAdder.png}{SubForm and sub form adder}{JS_subFormAdder}


\figref{JS_subformAdder} depicts the UI elements of the two classes. The routines and fields are inherited from the parent classes. The class \textit{SubFormAdder} has a button, which lets the user add new sub forms, which are appended into the sub form container. The class \textit{SubForm} has additionally to the parent class a delete button for the cases if the user wants to delete the added dataset.  

Listing \ref{JS_subFormRoutine} shows the relevant part of the code in the class \textit{SubFormAdder}. The essence of the class is that the constructor initiates an array (with "[]") in the form data object, to which the sub form data object will be added dynamically upon the click events. So if the user clicks the add button, then new object is initialized (\textit{subFormDataObject}), which will be the data object of the sub form. Important to note that this object will contain value of the selected option of the sub form adder with the key defined in the \textit{dataKey} field of the descriptor. After the initialization of the object, it is pushed to the array, and the new \textit{SubFormAdder} instance is created, whose container is appended to the sub form container of the sub form adder. 


\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={Sub form adder routine}, label=JS_subFormRoutine, captionpos=b, belowskip=1em, aboveskip=2em]
class SubformAdder {
	
	constructor(descriptor, formData){
		this.addButton = $("<div/>").text("Add").click(this.add)    
		this.subFormDescriptor = this.descriptor.subForm
		this.formData[this.descriptor.predicate] = []
	}

	add(){
		var subformDataObject = new Object()
		subFormDataObject[this.descriptor.dataKey] = this.selector.val()
		this.formData[this.descriptor.predicate].push(subFormDataObject) 
		this.subFormContainer.append(
				new SubForm(this, this.subFormDescriptor, subFormDataObject).container)
	}
}
\end{lstlisting}

The class \textit{SubForm} works almost the same way as its parent, but with the difference that it checks if there is such selector among its elements, whose data has to be loaded dynamically through AJAX, because its value is dependent on one or more previously set elements of the form.  

\newpage
\subsection{Server side} 

This section contains the discussion of the main elements of the implementation on the server. On the client side the JavaScript files containing the classes and libraries were just included into the generic template file, but the server side integration into VIVO is a more complicated issue, therefore the first subsection is dedicated completely to it. Furthermore the handling of the AJAX calls for form data with the variable dependencies are discussed here, as well as the routines how the graph model can save, edit and retrieve the data.

\subsubsection{VIVO integration}

In VIVO the form loading starts from the profile pages, from the property fields. Based on the property IRI the generator class is retrieved from the configuration triples (\figref{fauxRDF}), and the generator class returns an instance of \textit{EditConfigurationVTwo} class. The approach implemented in the frame of the thesis does not replace this scheme, but makes it simpler. The idea is that the complete definition is stored in one object called \textit{FormConfiguration} (listing \ref{dataDefinition}).

\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={Added field to the VIVO configuration class}, label=dataDefinition, captionpos=b, belowskip=1em, aboveskip=2em]
class EditConfigurationVTwo {
	...
	FormConfiguration formConfig;
	...
}
\end{lstlisting}

\figref{UML_fc} shows the UML class diagram \textit{FormConfiguration} class. The first field, (\textit{connector} connects the server implementation classes to the triple store (\figref{UML_wc}). This has to be implemented individually for VIVO. The \textit{mainGraph} field is the data definition, the \textit{form} is for the form, and the \textit{dependencies} and \textit{graphMap} are used by the AJAX calls. 

\img{\V}{UML_fc.png}{UML class diagram for FormConfiguration}{UML_fc}

\img{\V}{UML_wc.png}{UML class diagram for interface WebappConnector}{UML_wc}

\figref{initial} shows the process of loading of a custom entry form in VIVO. The first step is to find the generator class based on the value of the \textit{predicateUri} parameter of the initial request. If the class has been found, the processor algorithm is executed, and the necessary JSON and Java object are generated. Afterwards the server saves the form configuration object in its cache with a key, that is sent to the client in the \textit{editKey} JavaScript variable. The box in the middle of the image shows, that the response web page includes the JS libraries (simplified notation \textit{framework.js}), and the value of the \textit{editKey}. This is the value will be sent with each AJAX request to the server, and based on this parameter the can the server find the form configuration instance that returns the required JSON objects.

\img{\V}{initial.png}{Form loading process}{initial}

Upon the AJAX calls from the form, the class \textit{AJAXController} is called, which gets the found form configuration instance an the incoming JSON object (\textit{requestData}). Each AJAX call has a parameter \textit{task}, based on which the framework decides which operation has to be executed.

\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={AJAX request server routine}, label=serveRequest, captionpos=b, belowskip=1em, aboveskip=2em]
setResponse(FormConfiguration formConfig, JSONObject request) {
		switch (request.get("task")) {
			....
		}
}
\end{lstlisting}

\subsubsection{Form data loading}

Important part of the framework functionality is the loading of options of particular selectors on the forms. As it was mentioned, the variables on the form can be dependent on other values of the forms. The request has three main parameters :

\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={Example request data for form data}, label=serveRequest, captionpos=b, belowskip=1em, aboveskip=2em]
var formDataRequest = {
	task : "formData",
	variableToGet : "a",
	inputParameters : { b : "1", c : "2"} 
}
\end{lstlisting}

where the inputParameters is further JSON object, that contains the key-value pairs collected from the form. The AJAXController then finds the variable dependency instance from the \textit{dependencies} map based on the \textit{variableToGet} field:

\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={Loading form data from FormConfiguration}, label=serveRequest, captionpos=b, belowskip=1em, aboveskip=2em]
switch (request.get("task")) {
	...
	case "formData": 
		return dependencies.get(request.get("varToGet")).getData(request)
	...		
}
\end{lstlisting}

\figref{UML_vd} shows the UML diagram of the variable dependency. The most important field is the \textit{dependencies}, which is a set of triples describing the path from the input variables to the output variable. The methon \textit{getData} returns the JSONObject containing the list about the options.

\img{\V}{UML_vd.png}{UML class diagram for VariableDependency}{UML_vd}

In case, if the dependency is only one restriction triple, and there is only one input variable, the variable dependency class generates i.e. the following query.

\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={SPARQL query generated by class restriction triple}, label=JS_subFormRoutine, captionpos=b, belowskip=1em, aboveskip=2em]
SELECT ?outputVar ?label 
WHERE {
	?inputVar				rdfs:subClassOf			?restriction .
	?restriction		owl:onProperty			fma:systemic_part_of .
	?restriction		owl:someValuesFrom	?outputVar .
	?outputVar			rdfs:label					?label .	
	FILTER (?inputVar = fma:5058)
}
\end{lstlisting}

\newpage
\subsubsection{Saving, editing and retrieval of RDF Data}

For each data operation the class graph is responsible. Each data input process has a main graph (\textit{mainGraph} field of configuration), which consist of normally some sub graphs. Each graph instance contains the necessary fields to be able perform the requeired data operations (\figref{UML_graph}). 

\img{\V}{UML_graph.png}{UML class diagram for Graph}{UML_graph}

For the saving and retrieving the whole dataset is addressed, therefore the main graph is called, but if a particular subform is edited on the form the graph, whose data is changes retrieved from teh \textit{graphMap} map of the form configuration. 

\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={Loading form data from FormConfiguration}, label=serveRequest, captionpos=b, belowskip=1em, aboveskip=2em]
JSONObject serveRequest(JSONObject requestData){
switch (request.get("task")) {
...
case "saveData": 
	return mainGraph.saveData(request)
case "retrievedData": 
	return mainGraph.getData(request)
case "editData": 
	return graphMap.get(request).editData(requestData)
...		
}
\end{lstlisting}
