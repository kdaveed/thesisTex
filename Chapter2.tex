\chapter{Preliminaries}

\section{Semantic Web}

\subsection{Resource Description Framework}


The Resource Description Framework (RDF) is a metadata data model used for representing information on the web. The data in RDF is organized into triples, where each triple consist of a subject, predicate and object. The set of RDF triples constitutes a directed graph, which is referred as RDF graph. The nodes of the graph are the subject and the object, while the edges are the predicates.

In RDF there are three main type of nodes, instances, classes and literals. An instance represent concrete entities like person, institute or even abstract concepts. Classes are general concepts, to which the instances can belong, while literals represent data values assigned to instances. The following Listing shows some example triples that illustrates the basics of information representation in triples.

\begin{lstlisting}[basicstyle=\footnotesize, captionpos=b, caption=Information in triples, label=ex3, ,belowskip=1em, aboveskip=2em,
frame=single]
	Bob								instanceOf					Student  .
	Math							instanceOf					Course . 		
	Bob								attends							Math . 		
	Bob								avgGrade						1.73 .
\end{lstlisting}

In the example the \textit{Bob} and \textit{Math} are instance,the \textit{Course} and \textit{Student} are classes and the value 1.73 is literal. The values of the predicates are called properties. There are three main types of it, the one which connects instances to class (\textit{instanceOf}), one the expresses relationship between instances (\textit{attends}), and one which assigns a literal value to an instance (\textit{avgGrade}). 

\img{\II}{rdfData.png}{RDF Data}{rdfG}


\figref{rdfG} illustrate the three main type of nodes and triples in RDF graphs. In the following this type of notation will be used on the figures, namely ellipse for the classes, rectangle for the instances and rhombus for the literals.


In the following section we will see, that classes are in a certain sense are instance as well, and together the classes and instances are referred in the RDF world as resources. Each resource in an RDF graph has to have Internationalized Resource Identifier(IRI). There IRIs are grouped into specific namespaces. If someone wants to represent an information then it is necessary to choose an own namespace, which is the domain URI. For example if the choosen namespace is \textit{<http://myDomain.com\#>}, then the IRI of the first instance may instance \textit{<http://myDomain.com\#1>}, and the IRI of the class \textit{<http://myDomain.com\#Student>}. Since this namespace have to be unique these IRI are unique too. 

Due to the triple structure and RDF dataset can be stored by means of text document. There are different serialization formats, and the simples is the N3 format. In that format the namespaces can be abbreviated with predefined prefixes to make the RDF document more readable. Above the own domain the following listing contains three namespaces the RDF, RDF Schema (RDFS) and XML Schema.


\begin{lstlisting}[basicstyle=\footnotesize, captionpos=b, caption=RDF data in N3 serialization format, label=lst:sparql,
frame=single]
@prefix rdf:  	 <http://www.w3.org/1999/02/22-rdf-syntax-ns\#>
@prefix rdfs:   <http://www.w3.org/2000/01/rdf-schema#>
@prefix xsd:  	<http://www.w3.org/2001/XMLSchema\#>
@prefix domain:  <http://myDomain.com\#>

domain:1			rdf:type						domain:Student 	.
domain:1			rdfs:label					"Bob"^^xsd:string 	.
domain:2			rdf:type						domain:Course 	.
domain:2			rdfs:label					"Math"^^xsd:string 	.
domain:1			domain:attends			domain:2 	.
domain:1			domain:avgGrade			"1.72"^^xsd:float .
\end{lstlisting}


The property \textit{rdf:type} assing instance to classes, while the \textit{rdfs:label} assigns label to them. The XML Schema is standard for representing data types like \textit{string} or \textit{float}. The syntax for literals are the value and after comes the type. 

\subsection{RDF Schema}

The RDFS together with RDF offer classes and properties that allow to express the rules of the RDF data. In the previous section we just assumed there are the two classes and two properties, but this information has to be defined in the graph as well. For this definition there are two classes,  the \textit{rdfs:Class} and \textit{rdf:Property}. To define own properties and classes, just like by the instance the \textit{rdf:type} property is used.

\begin{lstlisting}[basicstyle=\footnotesize, captionpos=b, caption=Class definition, label=lst:sparql,
frame=single]
domain:Student					rdf:type						rdfs:Class .
domain:Course						rdf:type						rdfs:Class	.
domain:attends					rdf:type						rdf:Property .
domain:avgGrade					rdf:type						rdf:Property .
\end{lstlisting}

Furthermore there is an important modeling concept, the sub class. To express this type of relationship there is property in RDFS, the \textit{rdfs:subClassOf}. So the following triples adds new information to the model.

\begin{lstlisting}[basicstyle=\footnotesize, captionpos=b, caption=Class definition, label=lst:sparql,
frame=single]
domain:Person						rdf:type						rdfs:Class .
domain:Student					rdfs:subClassOf			domain:Person .
\end{lstlisting}

This means that if there is instance of the class \textit{domain:Student}, then it is automatically the instance of the class \textit{domain:Person} too. Further task is to define that the property \textit{domain:attends} can be the predicate of triples, where the subject is the instance of \textit{domain:Student} and the object is the instance of \textit{domain:University}. The same way for the \textit{domain:avgGrade} where the object is literal with the type floating point. For this definition there are two properties the \textit{rdfs:domain} and \textit{rdfs:range}.

\begin{lstlisting}[basicstyle=\footnotesize, captionpos=b, caption=Property definition I., label=lst:sparql,
frame=single]
domain:attends					rdfs:domain				domain:Student	.
domain:attends					rdfs:range				domain:Course .
domain:avgGrade					rdfs:domain				domain:Student	.
domain:avgGrade					rdfs:range				xsd:float	.
\end{lstlisting}

\figref{vocab} illustrates the essence of the vocabulary definition in general way. The white ellipses without notations are the classes of the vocabulary and the grey ellipse is the property. On the bottom the triple with predicate \textit{Property1} shows is valid, because it conforms to the domain and range definition.


\img{\II}{vocabulary.png}{RDF/RDFS Vocabulary}{vocab}


\img{\II}{rdf_vocab.png}{Class hierarchy of the RDF/RDFS vocabulary}{voc}


On the left of \figref{voc} the class \textit{rdfs:Class} is depicted. It is class since it is the instance of itself. The same way \textit{rdfs:Resource} is class. Furthermore \textit{rdfs:Class} is the sub class of the \textit{rdfs:Resource}, from which it follows that an instance of any class is resource too. 

The four grey ellipses (one contains two properties) represent the five most relevant properties in the RDF/RDFS vocabulary. Each of them are the instances of the class \textit{rdf:Property}, and for each the domain and the range classes are depicted.

\subsection{OWL}

Ontology Web Language(OWL) is an extension of the RDFS vocabulary \cite{Dean:04:OWO}. OWL offers several useful classes and properties, that allows more fine grained modeling. OWL has its own namespace, which is normally denoted with the \textit{owl} prefix.

\begin{lstlisting}[basicstyle=\footnotesize, captionpos=b, caption=OWL namespace, label=lst:sparql, belowskip=1em, aboveskip=2em,
frame=single]
PREFIX owl: <http://www.w3.org/2002/07/owl#>
\end{lstlisting}


\figref{owlVocab} shows a subset of the OWL vocabulary, that is relevant for the thesis.

\img{\II}{15_owl_vocab.png}{A subset of OWL vocabulary}{owlVocab}


Instead of depicting the range and domain of the particular properties in OWL, the following figure show the scheme of the definition of the types of restrictions used in our project.

\img{\II}{restrictionScheme.png}{Scheme of the restrictions}{restScheme}

On the left side the scheme of the value restriction, and on the left side the scheme of the qualified cardinality restriction is depicted. The multiple predicates on the figure shows the possible properties that can be applied for the triple. Important by both cases that the central restriction instance (rectangle) is not an RDF resource but a blank node. Blank nodes are such RDF nodes that do not have a IRI. Later in this section example will be provided about how they can be defined. 

The idea is that the restriction node encompasses the triples that describing the rule of the domain. The class on which the restriction is applied is the subclass of the restriction blank node, while the property is connected with the \textit{owl:onProperty} property. By the value restriction the \textit{owl:someValuesFrom}/\textit{owl:allValuesFrom} properties define the instances of \textit{ClassA} can constitute a triple with property \textit{Property1} at least with one instance/and only with instances of \textit{ClassB}. By the qualified cardinality restrictions there is an additional triple that asserts the how many instances have to present at least/exactly/at most, and the second class is assigned to the restriction node with the \textit{owl:onClass} property.

\img{\II}{ontExt1.png}{Ontology extension}{ontExt1}


In order to illustrate the utility of restrictions, the ontology from the previous section was extended with three subclasses (\figref{ontExt1}). The abbreviations \textit{CS} stands for computer science. The following two restriction asserts that a computer science student is allowed to attend only computer science course, and has to take at least two key courses.

\begin{lstlisting}[basicstyle=\footnotesize, captionpos=b, caption=Restrictions defined as blank nodes, label=lst:sparql, belowskip=1em, aboveskip=2em,
frame=single]
domain:CS_Student rdfs:subClassOf  [ 
	rdf:type					owl:Restriction ; 
	owl:onProperty		domain:attends ; 
	owl:allValuesFrom	domain:CS_Course .
]

domain:CS_Student rdfs:subClassOf  [
rdf:type										owl:Restriction ; 
owl:onProperty							domain:attends ; 
owl:onClass								  domain:KeyCourse; 
owl:minQualifiedCardinality "2"^^xsd:nonnegativeInteger .
] .
\end{lstlisting}


\subsection{SPARQL}

SPARQL is a query language for querying data in RDF graphs. A SPARQL query is a definition of a graph pattern through variables and constants. The following example query returns all IRIs that represent a football player: 

\begin{lstlisting}[captionpos=b, caption=SPARQL Query I., label=lst:sparql, belowskip=1em, aboveskip=2em, 
basicstyle=\footnotesize,frame=single]
SELECT ?student  
WHERE { 
	?student		rdf:type	domain:Student .	
}
\end{lstlisting}

In the example the query consist of only one triple. The subject is a variable and the predicate and the object are constant. Therefore the triple store looks all the triples and checks the predicate is rdf:type and the object is eg:FootballPlayer. 
It is well possible to not just ask the IRI of the players but further information by adding additional triples to the query in order to ask the name for example of the player:

\begin{lstlisting}[captionpos=b, caption=SPARQL Query II., label=2nd:sparql, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
SELECT ?student ?name 
WHERE { 
	?student		rdf:type	 domain:Student .	
	?student		rdfs:label	 ?label  .
	OPTIONAL { ?student	domain:avgGrade	?grade  } 
}
\end{lstlisting}

The result table in this case will contain two columns, one with the IRI of the person and one with their name. Important that it is as well possible to query blank nodes by introducing a variable for it. So if we want to list all the instances that are coming into question as player to a football team we can formulate the following query:

\begin{lstlisting}[captionpos=b, caption=SPARQL Query III., label=3rd:sparql, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
SELECT ?person ?name
WHERE {
	eg:FootballTeam	rdfs:subClassOf		?restriction .
	?restriction		rdf:type					owl:Restriction .
	?restriction		owl:onProperty		eg:hasPlayer .
	?restriction		owl:allValuesFrom	?playerType .
	?player					rdf:type					?playerType .
	?player					eg:name						?name . 
}
\end{lstlisting}


\newpage
\section{Applied Ontologies} \label{22}

Ontologies are used to describe types, relationships and properties of objects of a certain domain. It is a common practice to used already defined 
ontologies rather developing an own. The first reason is, that the development of an ontology is a complex and a tedious process, and requires a lot of resource. Secondly, it is reasonable to use standardized vocabularies, in order to make data from same domain but different sources inter-operable.

\subsection{Foundational Model of Anatomy - \textit{FMA}}  \label{fma}

The foundational Model of Anatomy ontology is an open source ontology written in OWL. FMA is a fundamental knowledge source for all biomedical domains, and it provides a declarative definition of concepts and relationships of the human body for knowledge based applications. It contains more than 70 000 classes, and 168 different relationships, and organize its entities into a deep subclass tree \cite{Rosse2003478}. All types of anatomical entities are represented in FMA, like molecules, cells, tissues, muscles and of course bones. In our project we use only the subset of the FMA. The taken elements are the subclasses of the following two classes and the three properties: 

\begin{itemize}
	\item{Classes}
		\subitem \textit{Subdivision of skeletal system} - fma:85544 
		\subitem \textit{Bone Organ} â€“ fma:5018
\end{itemize}

\begin{itemize}
	\item{Properties}
		\subitem \textit{fma:systemic\_part\_of}
		\subitem \textit{fma:constitutional\_part\_of}
		\subitem \textit{fma:regional\_part\_of}
\end{itemize}

The class \textit{Bone Organ} is the superclass of all bones in the human skeleton. Each bone belong to a skeletal subdivision and a skeletal subdivision can be a part of another skeletal subdivision. This relationship in both cases is expressed by the property \textit{fma:systemic\_part\_of}. To define which bone organ belongs to which skeletal subdivision FMA uses OWL restrictions (see \figref{fma1}). The properties \textit{fma:constitutional\_part\_of} and \textit{fma:regional\_part\_of} \textit{fma:constitutional\_part\_of} are discussed later.

\img{\III}{1ontologyStructure.png}{Ontology structure for skeleton}{fma1}

Finally the advantage of using the FMA ontology is that, if in the future further elements of the human body have to be addressed by the research processes, i.e. muscles, then these classes can be easily integrated to the currently applied subset.

\subsection{Ontology for Biomedical Investigations - \textit{OBI}} \label{obi}


The aim of OBI ontology, is to provide the formal representation of the biomedical investigation in order to standardize the processes among different research communities. It is a result of a collaborative effort of several working groups, and it continuously evolving as new research methods are being developed. Its main function to describe the rules how biological and medical investigations have to be performed. OBI reuses terms from BFO \textit{Basic Formal Ontology} IAO \textit{Information Artifact Ontology} and  OBO \textit{Open Biological and Biomedical Ontologies} \cite{10.1371/journal.pone.0154556}. To define processes OBI uses the following three general classes:

\begin{itemize}
	\item  \textit{Information Content Entity} - obo:IAO\_0000030
	\item  \textit{Material Entity} - obo:BFO\_0000040
	\item  \textit{Process} - obo:BFO\_0000015
\end{itemize}

Information Content Entity represent results of a specific measurement, while Material Entity stands for the objects, on which the meausurements have been performed. 
The Process could mean any kind of step within an investigation, from the planning, through execution till the conclusion.

\begin{itemize}
	\item  \textit{Planning} - obo:OBI\_0000339
	\item  \textit{Study Design Execution} - obo:OBI\_0000471
	\item  \textit{Drawing a conclusion} - obo:OBI\_0000338
\end{itemize}


In our project the following three properties are used:

\begin{itemize}
	\item  \textit{has part} - obo:BFO\_00000051
	\item  \textit{has specified input} - obo:OBI\_00000293
	\item  \textit{has specified output} - obo:OBI\_00000299
\end{itemize}


\section{Web applications}

\subsection{Fundamentals} \label{fundamentals}

\subsubsection{Client-sever architecture} \label{clientServer}

A web applications have two main units, the client and the server. The client is the application, which the user interacts with, while the server is an other application serves the request coming from the client. The client and server programs are running normally on different machines, and they communicate through Hypertext Transfer Protocol (HTTP). The main mechanism is that client, which is a web browser application, sends an HTTP request through the web. The server is found based on the URI of the HTTP request, and upon the content of the request the server returns a document written in Hypertext Markup Language (HTML). The HTML document contains the definition of the elements of the interface and it is interpreted by the web browser.

\imgK{\II}{1_client_server.png}{Client server communication}


An HTML document consist of different elements like buttons, tables input fields. Each element is represented by specific tags. The HTML has a hierarchical structure, and each element is the child of the tag \textit{html}. On listing \ref{exHTML} it can be seen that each tag has a opening and closing element. 

\begin{lstlisting}[captionpos=b, caption=Example HTML document, label=exHTML, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
<html>
	<div class = "welcome">  Welcome on the web application </div>
	<a href="http://webapp.com/page1"> Page 1 </a>
</html>
\end{lstlisting}

The tag, like the \textit{html} in the example can contain further tags, and have normally at least one paramater (i.e \textit{class} and \textit{href}). The tag \textit{div} is the most general element of web pages, while the \textit{a} tag defines link, where the \textit{href} parameter is defines the URI of the HTTP request they initiate. The request of the example link arrives to the same server, and the task of the application is to process the request URI and return the HTML document for the new page. 


\subsubsection{Data driven web applications} \label{dataDriven}

Most of the web applications nowadays incorporates databases. Databases are used to store large amount data in an organized way. Databases are always come along with a database management system (DBMS), that allows to create, edit, delete and retrieve data in the database. So DBMS is software that acts as an interface between the web application and the data. In the following, the database and DBMS together will be referred just as database.  

By web applications using databases the most important point, that web pages are not statically defined in HTML files, but generated by the application dynamically using a particular dataset. The process of loading of a web pages showing any data, starts with the execution of a query. This means the web application sends a query to the database and gets a desired data. The result of a query in terms of the web application is conventionally a list of data objects.  The term object is used generally, and refers to a data type that organizes its values by keys. The elements of the output list represent the rows of the query result table, and the fields of the object in turn the rows respectively. 

To define how the web page has to generated from the dataset a so-called template file are used. The template file is basically an HTML document, that is extended with some additional syntax, which can be interpreted by the template engine. There a lot of template engines and technologies, but in the following I provide an illustrative example from \textit{Freemarker} template language, that is used by as well the VIVO framework.

\begin{lstlisting}[captionpos=b, caption=Template file example, label=skullJSON, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
<#list students as student>
	<tr>
		<td>${student.name}</td>
		<td> <@linkButton "grades" ${student.id} /> </td>
	</tr>
</#list>
\end{lstlisting}

Important that the data that is passed to the template engine has a name, by which it is referred in the template file. In the example query result is stored in a variable \textit{students}, where each student object has two keys, the \textit{name} and \textit{id}. The tag \textit{\#list} represent a loop, that iterates through the input list. The content withing the \textit{\#list} tag appear as many times in the resulting HTML, as many elements the input list have. The variables withing normal HTML tags are accessed with \textit{\$\{..}\}. 

Other useful feature of templates that it allows the definition of macro, which acts like subroutines in programming. In the example the macro \textit{\@linkButton} takes two input parameter and generates the \textit{<a/>} tag with a certain image. This make the development more convenient and clear.

\begin{lstlisting}[captionpos=b, caption=Macro definition, label=skullJSON, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
<#macro linkButton urlMapping id>
	<a href="webapp.com/${urlMapping}?id=${id}">
		<img src="webapp.com/images/jump.jpg"/>
	</a>
</#macro>
\end{lstlisting}


In the macro definition it can be seen that the url of the link contains the parameter \textit{id}, which is an additional information in the HTTP request. The idea is that the request is handled by a such server routine that substitutes the value of the parameter into a query, in order to get data about individuals. Then the returned page may contain additional link for further data entries. This is the fundamental method how web pages are used to discover data from databases.

\subsubsection{Interactive web pages}

The previous section showed the principles of how data can be browsed by means of web pages and links. In such static cases the HTML document was assembled completely by the server, and the links initiated the loading of whole new pages. Nevertheless it is often more efficient and leads to better user experience if the new content is added dynamically to the current web page. Such functionality can be achieved with JavaScript (JS), which is a scripting language run by the browser. The two most fundamental features of JS, that it is capable of storing data in variables and can modify the content of HTML elements of the pages. 

\img{\II}{js2.png}{Static and dynamic web pages}{js2}

\figref{js2} illustrates the difference between static and dynamic web pages, where the blue rectangle stand for the client side. The idea of dynamic web pages in data driven web applications, that if new content has to be shown on the page, then not an HTTP request is sent to the server, but a JS routine is called. JS code is defined in the HTML document within the \textit{<script/>} tag. The routines are assigned to HTML elements by their id-s in the following way:

\begin{lstlisting}[captionpos=b, caption=JavaScript routine assigned to an HTML element, label=jsListing, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
	<html>
		<div id = "button"> Show content </div>
		<div id = "content"></div>
		<script>
			...
			$("#button").click(function(){
				$("#content").text(data)
			})
			...	
		</script>
	</html>
\end{lstlisting}


This simple JS code illustrates how it is possible to load new content to the HTML element. In the example the \textit{append} function sets the text of the div with id \textit{button}. The \textit{data} is a JS variable holding
some text. The value variable can be either initialized by the server by the page assembly, or by AJAX calls. AJAX is an acronym for \textit{Asynchronous JavaScript and XML}. The AJAX is technology that allows JS to load data from the server asynchronously, which means that the request is initiated through JS routine, and response arrives as well to JS routine. The data by AJAX is mostly is JSON format. JSON stands for \textit{JavaScript Object Notation}, which is a standard data format. A JSON object consists of a set of key-value pairs, where the value can be any data, arrays or even further objects.

\begin{lstlisting}[captionpos=b, caption=JSON object example, label=jsListing, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
{	key1 : "data",
	key2 : ["value1", "value2"],
	key3 : { key : "value"}  }
\end{lstlisting}


\subsection{VIVO framework} \label{vivo}


VIVO is an open source web application framework, developed particularly for browsing and editing RDF data. VIVO utilizes that the data scheme in RDF is stored by means of triples as well, and it can adopt the pages to the ontology. It offers an ontology editor and there are particular features of the application that can be customized through a specific configuration dataset. This dataset is in RDF format too, and defines the way in which the data is displayed and edited on the web pages. VIVO allows to manipulate this configuration triples via the web interface, which enables the extension of the application to some extent conveniently without coding.

VIVO maintains two basic type of pages. The first is for displaying the existing data, and one for creating and editing data. The former will be referred as profile page, because it shows the data related to one individual RDF instances, and the latter will be referred as entry form. 


\subsubsection{Profile pages} \label{vivoPp}

The task of the profile pages in VIVO, is to display all instances and literals that constitute to a triple with the instance, whose page has been called. These neighbor nodes are shown on the page grouped into the properties. Furthermore the properties are organized into so-called property groups. A property groups can be defined through the following set of configuration RDF triples. 

\begin{lstlisting}[captionpos=b, caption=Property group definition, label=jsListing, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
vivo:overView				rdf:type			vivo:PropertyGroup .
vivo:overView				rdfs:label			"Overview" .
\end{lstlisting}

As we can see there is a class vivo:PropertyGroup, which indicates that VIVO incorporates a small ontology for web application configuration. Any property of a domain ontology loaded into VIVO can be assigned to a property group by an additional RDF triple:

\begin{lstlisting}[captionpos=b, caption=Assigning property to propery group, label=jsListing, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
obo:OBI_00000299		vivo:inPropertyGroup 		vivo:overView .
\end{lstlisting}


This means if an applied ontology is extended with further properties then they just have to be assigned to a property groups and VIVO profile pages can display them, and no modification is required in the template file or in the application code.

Other useful configuration possibility are offered by the so-called faux properties, which allow further grouping of RDF instances on the profile pages. They make possible to group instances based on their types even if they are connected to the main instance with the same property. Their definition lies in RDF triples as well, and for each one the base property, the range class and property group has to be set.

\img{\II}{faux.png}{Faux properties on VIVO profile pages}{faux}


\figref{faux} show a profile page of skeletal inventory. The blue entries represent the instances, and they are links to the profile pages of the individual skeletal subdivision. Both the \textit{Skull} and the \textit{Vertebral column} instances are connected to the skeletal inventory with the property \textit{rdfbones:hasSkeletalSubdivision}, but since two faux properties (\textit{skull} and \textit{vertebral column}) are defined, these instances appear separately on the profile page.

\subsubsection{Custom entry forms} \label{vivoCef}

Important part of the application is the creation of new RDF data. On \figref{faux} next to the property field, a button with a + sign can be seen, which is link to a data entry form page. The peculiarity of VIVO that from each property field, the request arrives to the same handler routine on the server. These requests have always three parameters:

\begin{itemize}
	\item{subjectUri}
	\item{predicateUri}
	\item{rangeUri}
\end{itemize}

Where the first is the URI of the instance to whom the profile page belongs, the second is the URI of the property (can be a faux property), and the third is the URI of the range class of the property. By default VIVO redirects the user to such an entry form where only one instance or literal can be added. However it is possible to define conveniently custom forms for more complex datasets.

By custom data input processes, there are two main parts to define. The first is the elements of data input form in HTML, and the second is the RDF data that has to be created. In VIVO these definition have to placed into a class, and the class have to be assigned to the property with again RDF configuration triples. 

\begin{lstlisting}[captionpos=b, caption= Entry form generator class definition, label=skullJSON, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
rdfbones:hasSkeletalSubdivision		vivo:customEntryForm	
		"rdfbones.SkeletalSubdivisionFormGenerator.java".
\end{lstlisting}

Thus if the request from the profile page arrives to the server, VIVO queries the class name by the parameter \textit{predicateUri} and instantiates it. By writing a class during the development incorporates the static definition of its variables. Each customly defined class implements a predefined VIVO interface, thus there is a specific set of variables that have to be initialized for the definition. The most important is the string variable \textit{templateFile}, that holds the name of template file that have to be displayed.


\begin{lstlisting}[captionpos=b, caption= Form defintion in Java, label=skullJSON, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
	this.templateFile = "subdivision.ftl"
\end{lstlisting}

Of course this template file has to be created too. The following code shows the definition of a template file using \textit{Freemarker} macros.

\begin{lstlisting}[captionpos=b, caption= subdivision.ftl, label=skullJSON, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
<form>
	<@selector	"type">
	<@textField	"nr">
	<@floatField "weight">
	<@submitButton>
</form>	
\end{lstlisting}

In the provided example there is one selector on the form, which allows the selection of the type of the new skeletal subdivision. Furthermore there are two literal fields, one for the catalog number and one for the weight. VIVO contains some useful \textit{Freemarker} macros that makes the form definition quicker. Each form element has to have a variable name, through its value after the submission can be identified.
 
The next fundamental variable of the generator class is the \textit{triplesToCreate}, which contain the RDF triples to be created during the data input process. 

\begin{lstlisting}[captionpos=b, caption= RDF Triples to create, label=skullJSON, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
this.triplesToCreate = "
	?subjectUri		rdfbones:hasSkeletalSubdivision		?subDivision.
	?subDivision	rdf:type													?type.
	?subDivision	eq:catalogNr											?nr.
	?subDivision	eq:weight													?weight. "
\end{lstlisting}


It can be seen that there are variables like in SPARQL, defined with question mark. Furthermore it has to be defined for each one variable what types are they. For this purpose there are three lists, on for the URIs on the form, one for the literals on the form, and for the new instances, whose URI do not come from the form but will be generated during the data creation.

\begin{lstlisting}[captionpos=b, caption= Variable type definition, label=skullJSON, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
	this.urisOnForm = {"type"};
	this.literalsOnForm	= {"nr", "weight"};
	this.newInstances = {"subDivision"};
\end{lstlisting}


The last type of the definition in such simple case, is to define the SPARQL query that retrieves the options for the selector fields on the form. This variable is \textit{Map<String, String>} type in Java. The keys of the map are the variable names, and the values are the SPARQL queries.

\begin{lstlisting}[captionpos=b, caption= Query for form data, label=skullJSON, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
this.formVariables.put("type", 
	"SELECT ?uri ?label
		WHERE {
		?uri	rdfs:subClassOf		?rangeUri	.
		?uri	rdfs:label			?label	.	}
\end{lstlisting}

This query is executed before the form page loading, and the result is passed to the template engine, which generates the options withing the \textit{selector} macro. Please note that the variable \textit{rangeUri} coming as an input with the HTTP request. This way it is ensured that the type of the \textit{subDivision} variable, will be the subclass of the range class.

These section gave an insight into how it is possible to define data input processes in a declarative way within the VIVO framework.





