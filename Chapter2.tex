\chapter{Preliminaries}

\section{Semantic Web}

\subsection{Resource Description Framework}


The Resource Description Framework (RDF) is a metadata data model used for representing information on the web. The data in RDF is organized into triples, where each triple consist of a subject, predicate and object. The set of RDF triples constitutes a directed graph, which is referred as RDF graph. The nodes of the graph are the subject and the object, while the edges are the predicates.

The three most important type of nodes are the instances, classes and literals. An instance represent concrete entities like person, institute or even abstract concepts. Classes are general concepts, to which the instances can belong, while literals represent data values assigned to instances. The following Listing shows some example triples that illustrates the basics of information representation by means of triples.

\begin{lstlisting}[basicstyle=\footnotesize, captionpos=b, caption=Information in triples, label=ex3, ,belowskip=1em, aboveskip=2em,
frame=single]
	Bob								instanceOf					Student  .
	Math							instanceOf					Course . 		
	Bob								attends							Math . 		
	Bob								avgGrade						1.73 .
\end{lstlisting}

In the example \textit{Bob} and \textit{Math} are instances, and they represent a concrete existing person and Math course of some university. The \textit{Course} and \textit{Student} are classes and the value 1.73 is literal. The values of the predicates are called properties. There are three main types of it, the one which connects instances to class (\textit{instanceOf}), one the expresses relationship between instances (\textit{attends}), and one which assigns a literal value to an instance (\textit{avgGrade}). 

\img{\II}{rdfData.png}{RDF Data}{rdfG}


\figref{rdfG} illustrates the three main type of nodes and properties in RDF graphs. In the following this type of notation will be used on the figures, namely ellipse for the classes, rectangle for the instances and rhombus for the literals.


The example gave just an insight into triple based modeling, but of course the nodes \textit{Bob} and \textit{Student} are not valid RDF nodes. The instances and classes are called resource, and each of them in an RDF graph has to have Internationalized Resource Identifier(IRI). The IRIs have to be unique, thus if someone want if someone wants to represent an information in RDF, then it is necessary to choose an own namespace. For example if the choosen namespace is \textit{<http://myDomain.com\#>}, then the IRI of the class \textit{Student} may be \textit{<http://myDomain.com\#Student>}.


RDF data does not contain only IRIs from own namespaces, but there are vocabularies that offer a set a built in IRIs. The three most important vocabulary is the RDF, RDF Schema (RDFS), XML Schema (XMLS).  RDF and RDFS offer classes and properties, while XMLS contains the datatype IRIs for literal values, and each them of these vocabularies have its own namespace.

RDF data can be stored in text documents. These document can have various serialization format. In RDF documents to improve readability, the namespaces are abbreviated with prefixes, and IRIs are represented with a prefix:suffix syntax. The meaning of this syntax is the concatenation of the prefix and the suffix. The following Listing shows a valid RDF document containing the triples of the example.

\begin{lstlisting}[basicstyle=\footnotesize, captionpos=b, caption=RDF data in N3 serialization format, label=lst:sparql,
frame=single]
@prefix rdf:  	 <http://www.w3.org/1999/02/22-rdf-syntax-ns\#>
@prefix rdfs:   <http://www.w3.org/2000/01/rdf-schema#>
@prefix xmls:  	<http://www.w3.org/2001/XMLSchema\#>
@prefix domain:  <http://myDomain.com\#>

domain:1			rdf:type						domain:Student 	;
							rdfs:label					"Bob"^^xmls:string 	.
domain:2			rdf:type						domain:Course 	;
							rdfs:label					"Math"^^xmls:string 	.
domain:1			domain:attends			domain:2 	;
							domain:avgGrade			"1.72"^^xmls:float .
\end{lstlisting}

The \textit{";"} in N3 is used to divide predicate-object pairs that belong to the same subject. With this approach the subject do not have to written as many times as many triples it participates in.

The property \textit{rdf:type} expresses the \textit{instanceOf} relationship, while \textit{rdfs:label} is the most widely used property to assign label to instances. By the literals it can be seen, that they are surrounded with quotation marks and extended with the type notation from the XMLS vocabulary.


\subsection{RDF and RDFS Vocabularies}


In the previous section the RDF and RDFS vocabularies were already mention, but this section provides much more detailed information about their usage and utility. 


RDF and RDFS offers classes and properties that allows to express the rules of the RDF data. First of all it has to be defined, what IRIs represent classes and what properties. For this purpose there are two classes the \textit{rdfs:Class} and \textit{rdf:Property}. To define own properties and classes, just like by the instance the \textit{rdf:type} property is used.

\begin{lstlisting}[basicstyle=\footnotesize, captionpos=b, caption=Class and property definition, label=lst:sparql,
frame=single]
domain:Student					rdf:type						rdfs:Class .
domain:Course						rdf:type						rdfs:Class	.
\end{lstlisting}

In this way it is defined that in our dataset the instances will represent students and courses. The definition in the case of the properties is a bit more complex, because it has to be defined too, what type of subject and object they can connect. For this definition there are two properties in RDFS, the  the \textit{rdfs:domain} and \textit{rdfs:range} respectively.

\begin{lstlisting}[basicstyle=\footnotesize, captionpos=b, caption=Property definition I., label=lst:sparql,
frame=single]
domain:attends					rdf:type						rdf:Property ;
												rdfs:domain					domain:Student	;
												rdfs:range					domain:Course .
domain:avgGrade					rdf:type						rdf:Property .
												rdfs:domain					domain:Student	.
												rdfs:range					xmls:float	.
\end{lstlisting}

The previous two Listings contains the RDF triples defining an own vocabulary. The vocabulary is called as well ontology and purpose is to define the scheme of the data. 

\figref{vocab} illustrates the essence of the vocabulary definition in general way. It can be seen that property (Property1) and the classes (ellipses without notation) are the instances of the RDF and RDFS classes, and they connected with range and domain predicates. Moreover in the triple where the predicate is \textit{Property1}, the subject is the instance of the domain class, and object is the range class of the property. In the case of properties where the range is an XMLS type, the rule is the same, just the object is not an instance but literal.

\img{\II}{vocabulary.png}{RDF/RDFS Vocabulary}{vocab}


Furthermore there is an important modeling concept, the subclas. To express this type of relationship there is property in RDFS, the \textit{rdfs:subClassOf}. So the following triples adds new information to the model.

\begin{lstlisting}[basicstyle=\footnotesize, captionpos=b, caption=Sub class definition, label=lst:sparql,
frame=single]
domain:Person						rdf:type						rdfs:Class .
domain:Student					rdfs:subClassOf			domain:Person .
\end{lstlisting}

In order to provide a wider image from the RDF and RDFS vocabulary \figref{voc} show the further classes and properties.


\img{\II}{rdf_vocab.png}{Class hierarchy of the RDF/RDFS vocabulary}{voc}


On the left of \figref{voc} the class \textit{rdfs:Class} is depicted. It is class since it is the instance of itself. The same way \textit{rdfs:Resource} is class. Furthermore \textit{rdfs:Class} is the subclass of the \textit{rdfs:Resource}, from which it follows that an instance of any class is resource too. 

The four grey ellipses (one contains two properties) represent the five most relevant properties in the RDF/RDFS vocabulary. Each of them are the instances of the class \textit{rdf:Property}, and for each the domain and the range classes are depicted.

\subsection{OWL}

Ontology Web Language(OWL) is an extension of the RDFS vocabulary \cite{Dean:04:OWO}. OWL offers several useful classes and properties, that allows more fine grained modeling. OWL has its own namespace, which is normally denoted with the \textit{owl} prefix.

\begin{lstlisting}[basicstyle=\footnotesize, captionpos=b, caption=OWL namespace, label=lst:sparql, belowskip=1em, aboveskip=2em,
frame=single]
PREFIX owl: <http://www.w3.org/2002/07/owl#>
\end{lstlisting}


\figref{owlVocab} shows a subset of the OWL vocabulary, that is relevant for the thesis.

\img{\II}{15_owl_vocab.png}{A subset of OWL vocabulary}{owlVocab}


OWL extends the \textit{rdf:Property} with two subclasses. The \textit{owl:ObjectProperty} is represent the properties whose range is a class, while the \textit{owl:DataTypeProperty} is for those properties where the range is XMLS type. Instead of depicting the range and domain of the particular properties in OWL, the following figure show the scheme of the two types of restrictions used in our project.

\img{\II}{restrictionScheme.png}{Scheme of the restrictions}{restScheme}

On the left side the scheme of the value restriction, and on the left side the scheme of the qualified cardinality restriction is depicted. The multiple predicates on the figure shows the possible properties that can be applied for the triple. Important by both cases that the central restriction instance (rectangle) is not an RDF resource but a blank node. Blank nodes are such RDF nodes that do not have a IRI. Later in this section example will be provided about how they can be defined. 

The idea is that the restriction node encompasses the triples that describing the rule of the domain. The class on which the restriction is applied is the subclass of the restriction blank node, while the property is connected with the \textit{owl:onProperty} property. By the value restriction the \textit{owl:someValuesFrom}/\textit{owl:allValuesFrom} properties define the instances of \textit{ClassA} can constitute a triple with property \textit{Property1} at least with one instance/and only with instances of \textit{ClassB}. By the qualified cardinality restrictions there is an additional triple that asserts the how many instances have to present at least/exactly/at most, and the second class is assigned to the restriction node with the \textit{owl:onClass} property.

\img{\II}{ontExt1.png}{Ontology extension}{ontExt1}


In order to illustrate the utility of restrictions, the ontology from the previous section was extended with three subclasses (\figref{ontExt1}). The abbreviations \textit{CS} stands for computer science. The following two restriction asserts that a computer science student is allowed to attend only computer science course, and has to take at least two key courses.

\begin{lstlisting}[basicstyle=\footnotesize, captionpos=b, caption=Restrictions defined as blank nodes, label=lst:sparql, belowskip=1em, aboveskip=2em,
frame=single]
domain:CS_Student rdfs:subClassOf  [ 
	rdf:type					owl:Restriction ; 
	owl:onProperty		domain:attends ; 
	owl:allValuesFrom	domain:CS_Course .
]

domain:CS_Student rdfs:subClassOf  [
rdf:type										owl:Restriction ; 
owl:onProperty							domain:attends ; 
owl:onClass								  domain:KeyCourse; 
owl:minQualifiedCardinality "2"^^xmls:nonnegativeInteger .
] .
\end{lstlisting}


\subsection{SPARQL}


RDF data is stored most commonly in triplestores. A triplestore is software for storage and retrieval of RDF triples. The retrieval like by other kind of databases happens via queries, that are formulated in a particular query language. The query language for RDF is called SPARQL. 

A basic SPARQL query consists of two main parts. Firstly of a triple pattern, which differs only from a RDF dataset that it contains variables. The variable are denoted with a question mark in triple pattern. Secondly it contains a set of variables that the query has to return. Listing \ref{sparql1} shows an example query, through which the syntax is demonstrated. After the \textit{SELECT} keyword there is the variable to return and after the \textit{WHERE} keyword inside the parenthesis there is the triple pattern.

\begin{lstlisting}[captionpos=b, caption=SPARQL Query I., label=sparql1, belowskip=1em, aboveskip=2em, 
basicstyle=\footnotesize,frame=single]
SELECT ?student  
WHERE { 
	?student		rdf:type	domain:Student .	
}
\end{lstlisting}


It can be seen that the namespace abbreviation with prefixes works the same way like in RDF documents. If the query is executed on the dataset from \figref{sparqlData}, then it return the \textit{domain:1} and \textit{domain:3} instances for the variable \textit{?student}. 


\img{\II}{sparqlData.png}{Ontology extension}{sparqlData}



Furthermore the triple pattern can consists of  multiple triples as well, like in the following query:

\begin{lstlisting}[captionpos=b, caption=SPARQL Query II., label=2nd:sparql, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
SELECT ?student ?label 
WHERE { 
	?student		rdf:type	 domain:Student .	
	?student		rdfs:label	 ?label  .
}
\end{lstlisting}

Executed on the same dataset, this query return only the instance \textit{domain:1} because \textit{domain:2} does not have a label, thus there is not matching RDF node for variable \textit{?label}. This means that the triples in a triple pattern are in \textit{AND} relationship. But there is keyword optional that allow the definition of sub triple patterns, which are not required in the RDF dataset. So if the triple with the label variable is in the OPTIONAL sub pattern then the query II. return \textit{domain:3} instance as well, so that the variable for the label will be empty.

\begin{lstlisting}[captionpos=b, caption=Optional sub triple pattern., label=2nd:sparql, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
OPTIONAL { 	?student	rdfs:label	 ?label  . } 
\end{lstlisting}

Moreover its is possible to define filters on the variables. The most commonly used are the regular expression filter on literals. 

\begin{lstlisting}[captionpos=b, caption=Regex filter in SPARQL, label=2nd:sparql, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
FILTER regex(?label, "^Bo")
\end{lstlisting}

Finally it is possible in SPARQL to query blank nodes, the same ways with variables. The following query then queries the ontology and returns at least how many key course must be attended by a computer science student.

\begin{lstlisting}[captionpos=b, caption=SPARQL Query III., label=3rd:sparql, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
SELECT ?min
WHERE {
	domain:CS_Student	rdfs:subClassOf			?restriction .
	?restriction			rdf:type						owl:Restriction .
	?restriction			owl:onProperty			domain:attends .
	?restriction			owl:onClass				?courseType .
	?restriction			owl:minQualifiedCardinality		?min .
}
\end{lstlisting}


\section{Ontologies} \label{22}

Ontologies are used to describe types, relationships and properties of objects of a certain domain. It is a common practice to use existing ontologies rather than developing them by ourselves. The main reason for this lies in the fact that the ontology development is a time consuming and tedious process. Two ontologies are taken in the project, one for the human anatomy and one for biomedical investigations. In order to connect these two, during the project our own ontology (called as well \textit{RDFBones}) is developed too. Firstly the two applied ontologies will be discussed and lastly the \textit{RDFBones} ontology.

\subsection{Ontology for the anatomy of the human body}  \label{fma}

The ontology modeling the human body is called \textit{Foundational Model of Anatomy} (FMA). FMA is a fundamental knowledge source for all biomedical domains, and it provides a declarative definition of concepts and relationships of the human body for knowledge-based applications. It contains more than 70 000 classes, and 168 different relationships \cite{Rosse2003478}. All kind of anatomical entities are represented in FMA, like molecules, cells, tissues, muscles and of course bones. In our project we use only the skeletal system related subset of the FMA. The taken elements are the following classes (and its subclasses) and properties: 

\begin{itemize}
	\item{Classes}
		\subitem \textit{Subdivision of skeletal system} - fma:85544 
		\subitem \textit{Bone Organ} â€“ fma:5018
\end{itemize}

\begin{itemize}
	\item{Properties}
		\subitem \textit{fma:systemic\_part\_of}
		\subitem \textit{fma:regional\_part\_of}
		\subitem \textit{fma:constitutional\_part\_of}
\end{itemize}

The class \textit{Bone Organ} is the superclass of all bones in the human skeleton. Each bone belongs to a subclass of  the class \textit{Subdivision of skeletal system}. Moreover there are such skeletal subdivisions which are part of another skeletal subdivision. In both cases the relationship is expressed by the property \textit{fma:systemic\_part\_of}. To define which bone organ belongs to which skeletal subdivision, FMA contains \textit{owl:someValuesFrom} restrictions (Listing \ref{fmaOWL}).

\begin{lstlisting}[captionpos=b, caption=Rules of the skeletal system defined in OWL, label=fmaOWL, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
fma:BoneOrganX	rdfs:subClassOf [
	rdf:type						owl:Restriction ;
	owl:onProperty			fma:systemic_part_of ;
	owl:someValuesFrom	fma:SkeletalSubdivisionY .
]
\end{lstlisting}

These restrictions mean that a bone organ instance cannot stand on its own, but it has to be a systemic part of an appropriate skeletal subdivision instance. \figref{fma} shows the main structure of the applied subset of FMA by depicting the restrictions with red arrows, and the subclass relationships with dashed arrows.

\img{\II}{fma.png}{Ontology structure for the human skeleton}{fma}

Finally, the advantage of using the FMA ontology is that, if in the future further elements of the human body have to be addressed by the research processes, i.e. muscles, then these classes can be easily integrated to the currently applied subset.

\subsection{Ontology for Biomedical Investigations (OBI)} \label{obi}

The aim of the OBI ontology, is to provide formal representation of the biomedical investigations in order to standardize the processes among different research communities. It is a result of a collaborative effort of several working groups, and it is continuously evolving as new research methods are being developed. Its main function is to provide a vocabulary that allows the definition of the rules regarding how biological and medical investigations have to be performed. OBI reuses terms from the  \textit{Basic Formal Ontology} (bfo), from the \textit{Information Artifact Ontology} (iao) and from the \textit{Open Biological and Biomedical Ontologies} (obo) \cite{10.1371/journal.pone.0154556}. The most important classes and properties adopted by the \textit{RDFBones} project are the following ones:

\begin{itemize}
	\item{Classes}
	\subitem  \textit{Investigation} - obo:0000015
	\subitem  \textit{Process} - bfo:0000015
	\subitem  \textit{Entity} - bfo:0000001
	\subitem  \textit{Information Content Entity} - iao:0000030
	\item{Properties}
	\subitem  \textit{has part} - bfo:00000051
	\subitem  \textit{has specified input} - obi:00000293
	\subitem  \textit{has specified output} - obi:00000299
\end{itemize}

Above these classes several other classes have been taken, but they are sufficient to discuss the essence of ontological definition of investigations. The idea of \textit{RDFBones} project is to define custom investigations by defining subclasses of the above mentioned classes, and restriction on the properties, the same way like FMA describes the human skeleton. These further ontological statements are called extensions. The following image illustrates an example ontology extension for an investigation (the notation is the same like on \figref{fma}, just the restrictions are defined on the OBI properties). 

\img{\II}{obi.png}{Extending OBI ontology}{obi}

It can be seen that the investigation contains two processes (\textit{has part} predicate), and each process has various inputs and an output. In our case input entities are segments of bone organs but they could be any kind of material. During a particular process the input entities are studied, and the result of the study is an in information content entity instance, which represents some measurement value. The provided scheme is just an illustrative example and the modeling of an investigation in reality is more complex and involves more OBI classes. They will be discussed in a bit more detail in Chapter 4.

The conclusion is that with these classes and properties, OBI offers a powerful vocabulary for defining custom investigations. The advantage of such ontological description is that everything is stored by means of RDF triples, and therefore it is possible to develop software applications which generates user interfaces based on the results of SPARQL queries performed on the extensions. From this follows that these formal do not acts just for data model but can be considered as software specification as well.

\subsection{RDFBones ontology}

\textit{RDFBones} ontology is an extension of the OBI ontology. It has its own namespace (the empty string a valid prefix too): 

\begin{lstlisting}[basicstyle=\footnotesize, captionpos=b, caption=RDFBones namespace, label=lst:sparql, belowskip=1em, aboveskip=2em,
frame=single]
PREFIX : <http://w3id.org/rdfbones/core#>
\end{lstlisting}

\figref{rdfbones} shows the four most important classes (blue ones) as subclasses of further OBI classes using the above defined prefix. On the left, there is class \textit{:SkeletalInventory}, whose purpose is to incorporate the set of existing bones in a skeletal collection. The \textit{Completeness2States} and \textit{Completeness2StatesLabel} classes are used to represent if a bone segment is complete or just partly present. The \textit{:SegmentOfSkeletalElement} is the subclass of \textit{bfo:0000020}, which is the subclass of the previously mentioned \textit{Entity} class. With this class for bone segments, \textit{RDFBones} makes possible the definition of custom segments of particular bone organs, in order to allow more fine grained modeling of the research activity. It is again a sort of ontology extension, thus the definition has to be done by means of custom subclasses and restrictions. The property that expresses the relationship between bone organs and bone segments is the \textit{fma:regional\_part\_of}. Also this is the property that connects the RDFBones and thus the OBI to the FMA.

\img{\II}{rdfbones.png}{RDFBones as OBI extension}{rdfbones}


\section{Web applications}

Nowadays web applications are prevalent since they have the advantage against desktop application that they do not have to be installed on local computer, and can be accessed from web browser and thus can be used anywhere from the world. Like by the ontologies, the development of a web application is a complex process, and therefore an existing open-source framework called VIVO has been applied in the project. VIVO is an appropriate choice, because it has been developed particularly for browsing and editing RDF data.  The designed software of the thesis is an extension of the VIVO framework. In order to provide the necessary information required to understand the problem and the solution of the thesis, this section covers some fundamental web application technologies and the main functionality and capabilities of VIVO framework.


\subsection{Fundamentals} \label{fundamentals}

\subsubsection{Client-sever architecture} \label{clientServer}

Web applications consist of two main units. The first is client, which the user interacts with, and the second is the server, which is an other application that serves the request coming from the client. The client and server programs are running normally on different machines, and they communicate through Hypertext Transfer Protocol (HTTP). The main mechanism is that client, which is a web browser application, sends an HTTP request through the web, and the server is found based on the URI of the HTTP request. Upon the content of the request the server returns a document written in Hypertext Markup Language (HTML). The HTML document contains the definition of the elements of the interface and it is interpreted by the web browser.

\imgK{\II}{1_client_server.png}{Client server communication}

An HTML document consists of different elements like buttons, tables input fields. Each element is represented by so-called tags. The HTML has a hierarchical structure, and each element is the child of the tag \textit{html}. On listing \ref{exHTML} it can be seen that each tag has a opening and closing element.

\begin{lstlisting}[captionpos=b, caption=Example HTML document, label=exHTML, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
<html>
	<div class = "welcome">  Welcome on the web application </div>
	<a href="http://webapp.com/page1"> Page 1 </a>
</html>
\end{lstlisting}

The tag, like the \textit{html} in the example can contain further tags, and have normally at least one paramater (i.e \textit{class} and \textit{href}). The tag \textit{div} is the most general element of web pages, while the \textit{a} tag defines link, where the \textit{href} parameter is defines the URI of the HTTP request they initiate. The request of the example link arrives to the same server, and the task of the application is to process the request URI and return the HTML document for the new page. 


\subsubsection{Data driven web applications} \label{dataDriven}

Most of the web applications nowadays incorporate databases. Databases are used to store large amount data in an organized way. Databases are always come along with a database management system (DBMS) that allows to create, edit, delete and retrieve data in the database. So DBMS is software that acts as an interface between the web application and the data. In the following, the database and DBMS together will be referred simply as database.  

By web applications using databases the most important point, that web pages are not statically defined in HTML files, but generated by the application dynamically using a particular dataset. The process of loading of a web pages showing any data, starts with the execution of a query. This means the web application sends a query to the database and gets a desired data. The result of a query in terms of the web application is conventionally a list of data objects. The term object is used generally, and refers to a data type that organizes its values by keys. The elements of the output list represent the rows of the query result table, and the fields of the object in turn the rows respectively. 

To define how the web page has to be generated from the dataset a so-called template file are used. The template file is basically an HTML document, that is extended with some additional syntax. The elements defined in this syntax can be interpreted by the template engine. There a lot of template engines and languages, but in the following I provide an illustrative example in \textit{Freemarker} template language, that is used within the VIVO framework.

\begin{lstlisting}[captionpos=b, caption=Template file example, label=skullJSON, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
<#list students as student>
	<tr>
		<td>${student.name}</td>
		<td> <@linkButton "grades" ${student.id} /> </td>
	</tr>
</#list>
\end{lstlisting}

Important that the data that is passed to the template engine has a name, by which it is referred in the template file. In the example query result is stored in a variable \textit{students}, where each student object has two keys, the \textit{name} and \textit{id}. The tag \textit{\#list} represent a loop, that iterates through the input list. The content withing the \textit{\#list} tag appear as many times in the resulting HTML, as many elements the input list have. The variables withing normal HTML tags are accessed with \textit{\$\{..}\}. 

Other useful feature of templates that it allows the definition of macro, which acts like subroutines in programming. In the example the macro \textit{\@linkButton} takes two input parameter and generates the \textit{<a/>} tag with a certain image. This make the development more convenient and clear.

\begin{lstlisting}[captionpos=b, caption=Macro definition, label=skullJSON, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
<#macro linkButton urlMapping id>
	<a href="webapp.com/${urlMapping}?id=${id}">
		<img src="webapp.com/images/jump.jpg"/>
	</a>
</#macro>
\end{lstlisting}

In the macro definition it can be seen that the url of the link contains the parameter \textit{id}, which is an additional information in the HTTP request. The idea is that the request is handled by such a server routine that substitutes the value of the parameter into a query, in order to get data about individuals. Then the returned page may contain additional link for further data entries. This is the fundamental method how web pages are used to discover data from databases.

\subsubsection{Interactive web pages}

The previous section showed the principles of how data can be browsed by means of web pages and links. In such static cases the HTML document was assembled completely by the server, and the links initiated the loading of whole new pages. Nevertheless it is often more efficient and leads to better user experience if the new content is added dynamically to the currently opened web page. Such functionality can be achieved with JavaScript (JS), which is a scripting language run by the web browser. The most fundamental features of JS, that it is capable of storing data in variables and can add, edit or remove HTML elements of the pages. 

\img{\II}{js2.png}{Static and dynamic web pages}{js2}

\figref{js2} illustrates the difference between static and dynamic web pages, where the blue rectangle stand for the client side. The idea of dynamic web pages in data driven web applications, that if new content has to be shown on the page, then not an HTTP request is sent to the server, but a JS routine is called. JS code is defined in the HTML document within the \textit{<script/>} tag. The routines are assigned to HTML elements by their id-s in the following way:

\begin{lstlisting}[captionpos=b, caption=JavaScript routine assigned to an HTML element, label=jsListing, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
	<html>
		<div id = "button"> Show content </div>
		<div id = "content"></div>
		<script>
			...
			$("#button").click(function(){
				$("#content").text(data)
			})
			...	
		</script>
	</html>
\end{lstlisting}

This simple JS code illustrates how it is possible to load new content to the HTML element. In the example the \textit{append} function sets the text of the div with id \textit{button}. The \textit{data} is a JS variable holding
some text. The value variable can be either initialized by the server by the page assembly, or by AJAX calls. AJAX is an acronym for \textit{Asynchronous JavaScript and XML}. The AJAX is technology that allows JS to load data from the server asynchronously, which means that the request is initiated through JS routine, and response arrives as well to JS routine. The data by AJAX is mostly is JSON format. JSON stands for \textit{JavaScript Object Notation}, which is a standard data format. A JSON object consists of a set of key-value pairs, where the value can be any data, arrays or even further objects.

\begin{lstlisting}[captionpos=b, caption=JSON object example, label=jsListing, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
{	key1 : "data",
	key2 : ["value1", "value2"],
	key3 : { key : "value"}  }
\end{lstlisting}


\subsection{VIVO framework} \label{vivo}

VIVO maintains two basic type of pages. The first is for displaying, and the second for creating and editing RDF data. The former will be referred as profile page, because it shows the data related to one individual RDF instance, and the latter will be referred as entry form. Although the scope of the thesis is only the data input, the profile pages will be covered as well briefly in the first part, because the entry forms are dependent on them to some extent and they are relevant regarding the future work. The second part provides a simplified explanation of how the RDF data input works originally in VIVO, which is necessary to understand the utility of the idea proposed by the thesis.

\subsubsection{Profile pages} \label{vivoPp}

The task of the profile pages in VIVO is to display all instances and literals that constitute a triple with the instance, whose page has been called. These neighbor RDF nodes are shown on the pages grouped by the property, and properties organized into tabs. Further grouping possibility is offered by the so-called faux properties. By means of faux property definition, it can be achieved that instances on the profile pages are grouped by their class. 

\img{\II}{faux.png}{Faux properties on VIVO profile pages}{faux}

\figref{faux} shows the layout of a VIVO profile page of a skeletal inventory, where the in the skeletal subdivision propery group the two faux properties (\textit{skull} and \textit{vertebral column}) can be seen. The instances (blue entries) are both connected to the skeletal inventory with the \textit{rdfbones:hasSkeletalSubDivision} property, but as there two faux properties are defined for the classes \textit{-fma:5018 "Skull"-} and for \textit{-fma:13478 "Vertebral Column"-}, they appear in distinct property fields. The peculiarity of VIVO that these interface related problem are not defined in template files of Java classes but in RDF configuration triples. \figref{fauxRDF} a simplified dataset for a faux property description. The notation in the rectangle denotes the label of the instance, because its IRI is not relevant at this point. By the profile page generation only the triples regarding range class and the base propery are considered, the value for the custom entry form is for the data input. 

\img{\II}{fauxRDF.png}{Faux property descriptor RDF dataset}{fauxRDF}

On \figref{faux} next to the property field, a button with a + sign can be seen, which is link to a data entry form page. From each property field the request arrives to the same handler routine on the server. These requests have always three parameters (VIVO uses in its parameter names URI instead of IRI, which is an abbreviation for Unified Resource Identifier, but it does not make a difference):

\begin{itemize}
	\item{ \textit{subjectUri}} - IRI of the instance to whom the profile page belongs
	\item{ \textit{predicateUri}} -  is the IRI of the property (can be a faux property)
	\item{ \textit{rangeUri}} - IRI of the range class of the property
\end{itemize}

\subsubsection{Custom entry forms} \label{vivoCef}

By default VIVO redirects the user to such an entry form where only one instance or literal can be added with the type defined in the \textit{rangeUri} parameter. However it is possible to so-called entry custom forms for more complex datasets.

\img{\II}{entryForm.png}{Custom entry form for skeletal subdivision}{entryForm}

\figref{entryForm} shows the layout of an HTML form with three fields, where the user can enter specific values for a new skeletal subdivision. After the data entry if the submit button is clicked an HTTP request is sent to the server. This is a same type of request like by the link explained in the previous section, just the values of the parameters are set by the user.

The idea of custom entry forms in VIVO, that they allow the definition only of HTML input form layout and the dataset definition, and developer does not have to care about how the values from the form are substituted into the RDF data and how the new instances are generated. To perform the definition two files has to be created, a \textit{Freemarker}  template file (.ftl extension) for the form definition, and a Java class that contains in its fields the reference to the template file and the RDF data definitions. The name of the Java class is stored in the faux property definition (\figref{fauxRDF}), and thus VIVO can find it based on the \textit{predicateUri} parameter of the custom entry form HTTP request.
The template file definition is simple due to the \textit{Freemarker} macros provided in VIVO. Each type of input field has a distinct macro and have two input parameters, the parameter name and the title.

\begin{lstlisting}[captionpos=b, caption= subdivision.ftl, label=skullJSON, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
<form>
	<@title "Add skeletal subdivision">
	<@labelField "label" "Label">
	<@textField	"desc" "Description">
	<@booleanField "complete" "Complete">
	<@submitButton>
</form>	
\end{lstlisting}

The class has to extends the class \textit{EditConfigurationGenerator} class, thus the fields given. The variable \textit{templateFile} must hold the name of the template file.

\begin{lstlisting}[captionpos=b, caption= Form defintion in Java, label=skullJSON, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
	this.templateFile = "subdivision.ftl"
\end{lstlisting}

The next fundamental variable of the generator class is the \textit{triplesToCreate}, which contains the RDF triples to be created after the submission.

\begin{lstlisting}[captionpos=b, caption= RDF Triples to create, label=skullJSON, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
this.triplesToCreate = "
	?subjectUri		rdfbones:hasSkeletalSubdivision		?subDivision.
	?subDivision	rdf:type						?rangeUri .
	?subDivision	rdfs:label					?label^^xmls:string.
	?subDivision	domain:description	?desc^^xmls:string .
	?subDivision	domain:complete			?complete^^xmls:boolean . "
\end{lstlisting}

It can be seen that there are variables like in SPARQL, defined with question mark. These must be the same as the variable defined in the template for the input fields. Moreover there are three basic types of variables defined by the following three lists:

\begin{lstlisting}[captionpos=b, caption= Variable type definition, label=skullJSON, belowskip=1em, aboveskip=2em,
basicstyle=\footnotesize,frame=single]
	this.urisOnForm = {};
	this.literalsOnForm	= {"label", "desc", "complete"};
	this.newInstances = {"subDivision"};
\end{lstlisting}

These section gave an insight into how it is possible to define data input processes in a declarative way within the VIVO framework. 


