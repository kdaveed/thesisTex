\chapter{Problem Statement}

The first section discusses the problem general way by addressing the requirements on the software both for the client and the server side for more elaborate data input processes. The second section in turn refers to the use-cases of the \textit{RDFBones} project and to the limitations of VIVO by their implementation. Finally, the third part introduces the main elements the descriptor logic and gives and insight into the functionality of the developed framework. 

\section{Multi level data input}

In the previous chapter it has been discussed how can we implement simple data input forms within the VIVO framework. The simplicity of the illustrated problem lied in that the number of instances which were created through the process was constant, in particular one, and only a set of literal attributes were set by the user through HTML input elements. Nevertheless there are more complex entities consisting of several sub parts, where these sub parts are represented in the ontology with further classes. Consequently the RDF dataset for such entities incorporates multiple instances organized into a tree structure. \figref{ps1} shows and example ontology and an RDF dataset. The classes (ellipses) without notation are subclasses of the three main classes and their names are not relevant.

\img{\III}{ps1.png}{Ontology and RDF triples for complex entities}{ps1}

Such dataset poses the requirement for the input form, that the user has to be offered such interface elements which enable to add the components and subcomponents step by step. Adding a component means in terms of the form that a new sub form appears which contains further input fields for the component instance.

\img{\III}{ps2.png}{Multi level form}{ps2}

\figref{ps2} shows the layout of the form for multi level data. The additional element compared to the static HTML form is the field with an button for adding the sub forms. The dotted rectangle stands for the container element that encompasses the added sub forms. The form data contains the same way the key value pairs for the main form element, but it has an additional array field that contains the data objects of the sub forms. The sub form data object works the same way, if the have sub forms then they contains further arrays. To realize such functionality, JavaScript routine is required on the form, that ads the sub form elements to the container, and generates the appropriate form data upon the user actions.

Listing \ref{multiData} shows the JSON object generated during by form from \figref{ps2}, where the objects are surrounded with ("\{\}"), while the arrays with ("[]"). After the submission the server has to process this object by iterating through the arrays of them, and generate the appropriate RDF triples.

\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={Multi level form data in JSON}, label=multiData, captionpos=b, belowskip=1em, aboveskip=2em]
{	type : "eq:elementA",
	label : "Element_4391",
	components : [
		{ type : "eq:componentA1",
		  label : "Component_8531",	
		  subComponents : [ { ... } ],
		},{ 
			... 
		}]
}
\end{lstlisting}

Further challenge is that the options of the type selector on the sub forms, are dependent on the selected type of the parent form (the form which the sub form has been added from). This means that the client has to load asynchronously the values, by sending AJAX request containing the selected type value to server. The task of the server is to perform the query that retrieves the classes defined through restrictions in the ontology. The goal of this functionality is firstly to ensure that only such data is created that conforms to the rules defined in the ontology, secondly the interface is much more usable if not all the components are listed, just the ones that are belong to the selected element. Moreover in this way the validation on the server side after submission can be omitted.

Finally, really important part of the problem is the editing of the existing data. To allow the application has to restore the state of the form, in which it has been submitted by the data creation. In the previous chapter we have seen that it is currently solved by defining  SPARQL queries that retrieves the form variables. But since the form data is not just a set of key value-pairs but a multi level data object, this approach is not sufficient. An algorithm is required that generates the multi level JSON object from the existing triples iteratively. Furthermore after the arrival of the existing data to the client, an other routine has to reset the state of the form with the appropriate sub forms and certain selector options as well.

This section gave an insight into challenges of the multi level data input. The emphasis lied on that these problem require more complex form functionality and server algorithm. For such cases unfortunately VIVO does not provide any libraries or possibility for some declarative definition, thus these advanced forms has to be implemented almost from scratch, and poorly documented parts of the source code have to be understood.

\section{RDFBones use-cases in VIVO}

During the project two use-cases and their solutions are discussed. We have seen in the previous chapter is the data input process definition for various cases happens through the data definition of RDF triples with variable (graph pattern) and the the form layout. \figref{rdfBones1} and \figref{rdfBones2} illustrates the graph pattern and multi level form layout of the two most important cases. The yellow rectangles denotes the main nodes of the dataset. 

\img{\III}{rdfBones1.png}{Skeletal remain graph pattern and	form layout}{rdfBones1}

\img{\III}{rdfBones2.png}{Investigation graph pattern and form layout}{rdfBones2}

It can be seen that the graph consists of classes (ellipses) and instances (rectangles). The problem is that it would be necessary to define custom JavaScript routines for each cases, which adds the sub forms and handles the dependency between the particular selector fields. Moreover VIVO cannot process the multi level JSON object coming from the client after the submission base on this single triple pattern in string. Furthermore the individual variables in the triple pattern do not appear only once in the result dataset, thus their value cannot be defined with SPARQL a single queries.


\section{Solution scheme}

In VIVO the data input problems were solved with the instantiation of a set of fields of a certain Java class, based on which the generic algorithm creates and retrieves the data. The idea of the thesis is to design a vocabulary, which is a set of Java classes and field, that allows the expression of multi level problems in a compact way, an write the libraries both for the client and the server side that is capable of operating on the configuration data. The implementation of the different cases, would be not just the setting of field of a certain Java class but the instantiation of this objects. 

In the triple pattern definition the most fundamental improvement is that it is not stored as a string but as a set of different types of triple. First of all it is inevitable to let the framework know that some sub graph of the graph pattern may appear in multiple times in the resulting dataset, because the submission handler routine has to be prepared that a set of variables do not come as single values but an in array. For this purpose there is the element of the vocabulary called \textit{MultiTriple}. Moreover we have seen that there are various dependencies form elements, which are referring to restrictions classes in the ontology. As the restrictions can be considered as triple connects two classes with a property, this it can be expressed, with a triple the same way, and it is called \textit{RestrictionTriple}. \figref{solutionScheme} depicts the extended graph pattern definition, where the restriction triple are depicted with red arrow, and the multi triple with double line arrow.

\img{\III}{solScheme.png}{Extended RDF graph pattern definition}{solutionScheme}

For the form layout definition the different input element types are represented as well with Java classes, and the subclass of the \textit{FormElements} class. The formelements are the assigned to the \textit{Form} class. Important element is the \textit{SubformAdder} wich allow the multi dimensional definition of the forms. This hierarchical set of forms are then converted into the JSON object, and based on which the library on the client operates. Important that each formelement refers to variable in the graph pattern, so that the form can be informed by dependencies in case. 

\figref{frameworkFunctionality} functionality depicts the scheme of the functionality. The most important improvement wrt. to VIVO that there is processor that is capable of inferring some addition descriptor data object from the original descriptor objects. Such as SPARQL queries for the data dependencies and data retrieval.  


\img{\III}{332_1.png}{Framework functionality outline}{frameworkFunctionality}

