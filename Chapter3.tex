\chapter{Problem Statement}

\section{Challanges of the RDFBones project}

\subsection{Human skeleton}

The subject of the anthropological investigations is primarily human skeletal remains. To be able to create data about these remains, first of all an ontology is required. As the human skeleton is complex, the ontology is not developed by us, but an existing have been taken. The used ontology is the subset of FMA (Foundation Model of Anatomy) ontology. For us the two most important classes are the following: 

\begin{itemize}
	\item Subdivision of skeletal system - fma:85544  
	\item Bone Organ – fma:5018
\end{itemize}

The class Bone Organ is the superclass of all bones in the human skeleton.  Each bone belongs to a skeletal subdivision and a skeletal subdivision can be a part of another skeletal subdivision. This relationship in both case is expressed by the property fma:systemic\_part\_of. To define which bone organ belongs to which skeletal subdivision FMA uses OWL restrictions.

\imgK{\III}{1ontologyStructure.png}{Ontology structure for skeleton}

The most important skeletal subdivision for our project is the skull. Skull has the peculiarity that it consists not directly of bones but two of other subdivisions, which consists of the Bone Organ subclasses.

%
\imgK{\III}{skullScheme.png}{FMA scheme for skull} 

The following image illustrates then the data structure of skull.

\imgK{\III}{rdfSkull.png}{RDF Triple representation of a skull} 

To implement an entry form that allows the user to create such triple set takes considerably more effort then the cases explained in the previous sections, because not only key value pairs has to be sent from the client to the server, but a multi dimensional dataset. 

\subsection{Ontology Extensions}

It is often the case that in an investigation not only the bone itself, but also particular segments has to be addressed. However the bone segments of the bones are not standard, and they can differ according to researcher or research project. Therefore FMA do not contain any bone segment of the bone organs, and consequently we have to define it on our own. 
Important that the skeletal subdivision instances do not appear on the dataset on their own, but they are connected to Skeletal Inventories. Skeletal inventories are used to gather information about particular skeletal remains.  The following image show the triple structure of skeletal inventories.

\imgK{\III}{skelInv.png}{Skeletal Inventory Data Structure} 

The variable ?skeletalInventory is the instance of the class rdfbones:SkeletalInventory, while the ?boneSegment is from the class rdfbones:SegmentOfSkeletalElement. The core ontology of the project contains a subclass of the rdfbones:SkeletalInventory, the rdf:PrimarySkeletalInventory. This skeletal inventory type is for skeletal remain collections where only the whole bone organs have to be addressed.  The way to define custom bone segments is always through a custom skeletal inventories, which contains restrictions on the property obo:isAbout and on the class of custom bone segments. Of course the custom bone segments has to be assigned to the bone organ class they belong to, via restrictions on property obo:systemic\_part\_of. The following image illustrates the extension definition.


\imgK{\III}{ontExtScheme.png}{Ontology extension scheme}

As these extensions are expressed by OWL restriction the application can query the definitions. Consequently if the custom entry form is called from the profile of a skeletal inventory instance, then the entry form processor routine can ask, what bone segment are defined to the type of the subject variable coming as input, and can offer them on the interface.

\subsection{Study Design Execution}

In most investigations the researcher take a set of bones belong to one individual and examine different tokens. Tokens refer to specific features of parts or regions of bones. These token have particular expressions.

\imgK{\III}{glabExpressions.png}{Glabella and its expressions}

The previous images show the token called glabella, and its expressions. The task of the web application is let the researcher select one of the already added Nasal Bones (because on that bone is the glabella token), and set the expression of it. The following data structure models the process.

\imgK{\III}{studyDesEx.png}{Study Design Execution Data Structure}

Where the variable ?categoricalLabel represents the expression of the token. The values this variable can take are defined in the ontology extension. The variable ?boneSegment is the bone on which the glabella can be found. This instance won’t be as well newly created, but an already added bone has to be selected on the interface. The ?assay and the ?meausurementDatum variables are new instances.  To be able to generate an entry form for the problem, the following ontology extension has to be defined.

\imgK{\III}{extGlab.png}{Ontology extension for Glabella}


Mention that the task of the user is to add some elements if they exists or not.


\section{RDF Data input}

\subsection{Multi dimensional form}

As it was addressed in the previous section each data input process of the application can be modeled by means of a tree style data structure. This means in terms of the data of the form, that just single key-value pairs like by the static HTML form is not sufficient for the problem. Therefore the task is provide such an interface that allows the user to add dynamically subforms, whose data object will be stored in arrays. \figref{mdfl} illustrates the idea of the structure. 

\img{\III}{multiDimensionalForm.png}{Multi dimensional form layout}{mdfl}

So the forms consist of the selectors, and literalfield explained in the Chapter 1., but with an additional element that add further subforms. To achieve this JavaScript routine is required that adds the elements automatically and fills the form object with the data. The produced data of the form is looks as follows.


\begin{lstlisting}[captionpos=b, caption=JSON object of the form, label=3rd:sparql,
basicstyle=\footnotesize,frame=single]
{
	key1 : "value1",
	key2 : "value2",
	...
	subFormKey1 : [
	{
		key1_1 : "value1_1",
		...				
	}, { ... }]
}
\end{lstlisting}


\subsection{Form dependencies} \label{formDependencies}


\img{\III}{subformDependency.png}{Subform dependencies}{mdfl}

These dependencies can occur not only between subforms but as well by in form dependencies where the selector elements can change based on selections.

\subsection{Instance browsing}


\begin{itemize}
	\item Figure ~\ref{navigator3} shows a further option for instance selection. 
\end{itemize}

\img{\III}{navigator.png}{Navigator example}{navigator3}

\begin{itemize}
	\item The implementation requires on the server side query and the grouping of the result
	\item Client side - programming the navigator window
\end{itemize}


\subsection{Validation}

As by each form there is required field - required - restrictions
The client has to get the information, about restrictions, and so  


\subsection{Editing form data}
	
As it was already addressed in section \ref{vivoCef}, the dataset created by the forms have to be edited as well. By editing, the HTTP request calling the entry form contains an additional field, namely the \textit{objectUri}. Based on the data model of the form, the server has to prepare the dataset, in our case a JSON object. The challenge of the server implementation is that in such multi dimensional dataset, it is not sufficient to perform only one query for the whole form data.

\img{\III}{exampleDataModel.png}{Example data model}{exDatMod}

\begin{lstlisting}[captionpos=b, caption=SPARQL query for the form data, label={sparqlExisting},
basicstyle=\footnotesize,frame=single]
SELECT ?a ?b
WHERE {
	?objectUri		p1		?a .
	?objectUri		p2		?b .
	FILTER ( ?objectUri = <inputParameter>)
}
\end{lstlisting}

The example data model from \figref{exDatMod} helps to understand the problem in more detail. If the SPARQL query on \listref{sparqlExisting} for variables ?a and ?b with incoming \textit{objectUri} value were executed, then result table of the query is inconvenient to process. For example if there are two instances for both ?a and ?b present in the dataset, then the result table contains \textit{2 x 2 = 4} elements (\tableref{sparqlResult}).

\begin{table}

	\begin{center}
		\begin{tabular}{||c | c||} 
			\hline
			?a & ?b  \\ [0.5ex] 
			\hline\hline
			a1 & b1 \\ 
			\hline
			a1 & b2 \\
			\hline
			a2 & b1 \\
			\hline
			a2 & b2 \\ [1ex] 
			\hline 
		\end{tabular}
	\end{center}
	\caption{SPARQL Result}  \label{sparqlResult}
\end{table}


Therefore the data object of the form has to be retrieved gradually, by dividing the data model graph by the predicates, whose cardinality is larger than one.

The next step after that the server has prepared the multi dimensional JSON object for the client, is to restore the state of the form, in which it was submitted by the user. This requires firstly the filling of the fields with the existing values, and adding the sub forms based on the arrays. Secondly the options of the selectors must be loaded, so that they conform to the dependencies explained in section \ref{formDependencies}. 

Finally if a value of selector or literal field changes, or new sub forms has to be added or removed, the entry form data should not be completely sent again to the server, but only the data fields that are concerned by the modification. Thus it does not require a complete page reload, and these operation can be performed through AJAX calls. To achieve this the client has to be prepared to be able to send data modification requests to the server on change event of any form element or sub form.

\subsection{Saving data}













