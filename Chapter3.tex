\chapter{Problem Statement}


\section{Multi level data input}


In the previous chapter it has been discussed how can we implement simple data input forms within the VIVO framework. The simplicity of the illustrated problems lied in that the number of instances which were created through the forms was constant, in particular one, and only their types and literal attributes were set by the user through HTML input elements. 

\img{\III}{ps1.png}{Ontology and RDF triples for complex entities}{ps1}

Nevertheless there are such entities that are more complex, and they consist of several sub part, that are represented in the ontology with further classes. Such as a skeletal subdivision consists of bone organs, or a study design execution consists of assays, which consist of input bones and output data. Consequently the RDF dataset for such entities incorporates  multiple instances organized into a tree structure. \figref{ps1} shows and example ontology and an RDF dataset. The classes (ellipses) without notation are subclasses of the three main classes and their name does not play any role.

Such dataset means that the data input form has to offer such interface elements which allows the user to add the components step by step. Adding a component means in term of the form that a new sub form appears where in the simplest case its type and label can be set.

\img{\III}{ps2.png}{Multi level form}{ps2}

\figref{ps2} shows the layout of the form for multi level data. The additional element is the button for adding the components. The dotted rectangle stands for the container element that encompasses the sub forms. To realize such functionality a JavaScript routine is needed that adds the sub forms and put the data set by the user into a JSON object. The difference compared to the key-value pairs generated by the HTML \textit{<form/>} tag, is that 
in this case the form data contains arrays to store the dynamically added elements. So JavaScript by each addition of sub component, creates a new data object and pushes into the appropriate arrays. The data of the added object will be values from the sub form. This is the basic principle how the multi level data is being created on the form. Listing \ref{multiData} shows the JSON object generated during by form from \figref{ps2}, where the objects are surrounded with ("\{\}"), while the arrays with ("[]").

\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={Multi level form data in JSON}, label=multiData, captionpos=b, belowskip=1em, aboveskip=2em]
{	type : "eq:elementA",
	label : "Element_4391",
	components : [
		{ type : "eq:componentA1",
		  label : "Component_8531",	
		  subComponents : [ { ... } ],
		},{ 
			... 
		}]
}
\end{lstlisting}

Further challenges is that the options of the type selector of the sub forms are dependent on the selected type of the parent form (the form to which the sub form was added). This means that the client has to load asynchronously the values, by sending AJAX request containing the selected type value to server. The task of the server is to perform the query that retrieves the classes defined through restrictions in the ontology. Moreover the saving process after the submission requires algorithm on the server, which iterates through the arrays of the data object.

Finally important part of problem is the editing of the data. The first step by the editing is the restore the submitted data and send to the client. In the previous chapter we have seen that it is currently solved by defining  SPARQL queries that retrieves the form variables. But since the form data is not just a set of key value-pairs but a multi level object this approach is not sufficient. An algorithm is required that generates the multi level JSON object from the existing triples iteratively. Moreover the form has to process the existing data and restore the form layout, with the selector options as well. 

This section gave an insight into the problem. The emphasis lied on the multi level data requires more complex form functionality and more complex server algorithm. In such case the code is not really complicated but large amount. The goal of the thesis is to model this form and data scheme, and let the definition of such advanced functionality without coding, in declarative way. 


\section{Solution scheme}




