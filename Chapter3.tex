\chapter{Problem Statement}


\section{Multi level data input}

In the previous chapter it has been discussed how can we implement simple data input forms within the VIVO framework. The simplicity of the illustrated problem lied in that the number of instances which were created through the process was constant, in particular one, and only their types and literal attributes were set by the user through HTML input elements. 

\img{\III}{ps1.png}{Ontology and RDF triples for complex entities}{ps1}

Nevertheless there are more complex entities consisting of several sub parts, where these sub parts are represented in the ontology with further classes. Such as a skeletal subdivision consists of bone organs, or a study design execution consists of assays, which consist of input bones and output data. Consequently the RDF dataset for such entities incorporates multiple instances organized into a tree structure. \figref{ps1} shows and example ontology and an RDF dataset. The classes (ellipses) without notation are subclasses of the three main classes and their names are not relevant.

Such dataset poses the requirement for the input form, that the user has to be offered such interface elements which enable to add the components and subcomponents step by step. Adding a component means in terms of the form that a new sub form appears which contains further input fields for the component instance.

\img{\III}{ps2.png}{Multi level form}{ps2}

\figref{ps2} shows the layout of the form for multi level data. The additional element compared to the static HTML form is the field with an button for adding the sub forms. The dotted rectangle stands for the container element that encompasses the added sub forms. The form data contains the same way the key value pairs for the main form element, but it has an additional array field that contains the data objects of the sub forms. The sub form data object works the same way, if the have sub forms then they contains further arrays. To realize such functionality, JavaScript routine is required on the form, that ads the sub form elements to the container, and generates the appropriate form data upon the user actions.

Listing \ref{multiData} shows the JSON object generated during by form from \figref{ps2}, where the objects are surrounded with ("\{\}"), while the arrays with ("[]"). After the submission the server has to process this object by iterating through the arrays of them, and generate the appropriate RDF triples.

\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={Multi level form data in JSON}, label=multiData, captionpos=b, belowskip=1em, aboveskip=2em]
{	type : "eq:elementA",
	label : "Element_4391",
	components : [
		{ type : "eq:componentA1",
		  label : "Component_8531",	
		  subComponents : [ { ... } ],
		},{ 
			... 
		}]
}
\end{lstlisting}

Further challenge is that the options of the type selector on the sub forms, are dependent on the selected type of the parent form (the form which the sub form has been added from). This means that the client has to load asynchronously the values, by sending AJAX request containing the selected type value to server. The task of the server is to perform the query that retrieves the classes defined through restrictions in the ontology. The goal of this functionality is firstly to ensure that only such data is created that conforms to the rules defined in the ontology, secondly the interface is much more usable if not all the components are listed, just the ones that are belong to the selected element. Moreover in this way the validation on the server side after submission can be omitted.

Finally important part of problem is the editing of the data. The first step by the editing is the restore the submitted data and send to the client. In the previous chapter we have seen that it is currently solved by defining  SPARQL queries that retrieves the form variables. But since the form data is not just a set of key value-pairs but a multi level data object, this approach is not sufficient. An algorithm is required that generates the multi level JSON object from the existing triples iteratively. Furthermore after the arrival of the existing data to the client, an other routine has to reset the state of the form with the appropriate sub forms and certain selector options as well.

This section gave an insight into challenges of the multi level data input. The emphasis lied on that these problem require more complex form functionality and server algorithm. For such cases unfortunately VIVO does not provide any libraries or possibility for some declarative definition, thus these advanced forms has to be implemented almost from scratch, and poorly documented parts of the source code have to be understood.

\section{Solution scheme}

The aim of the thesis is to develop a web application framework that allows the definition of the data input processes on high-level declarative way. This means that the application development, which normally incorporates coding in HTML, JavaScript and Java, is reduced to the creation of simple descriptor dataset defining the form layout and the RDF dataset that has to be created.

The first task is to design a vocabulary that models the whole data input process. This vocabulary is the scheme of the descriptor dataset. The vocabulary, like an ontology contains the classes representing the entities of the problem domain, and their relationships and attributes.

\img{\III}{dl.png}{Classes and relationships of the vocabulary}{ss1}

\figref{ss1} depicts the main classes of the vocabulary with ellipses, and the relationships with arrows. The attributes and some further subclasses are not displayed here for the sake of readability, but they will be covered in the following chapter. The three classes on the left model the interface, and the other three on the right in turn are for the RDF data definition. The purpose of the class \textit{Form} form is to encompass the input fields. To achieve the multi level layout explained in the previous section, the vocabulary contains an input field class \textit{SubformAdder}, to which a sub form can be defined with the \textit{subForm} relationship. The connection between the form and data model is expressed with the \textit{represents} relationship, which establish the basis of the substitution of the values of the input fields into the RDF nodes after the submission. To model the dataset the two main classes are the \textit{Triple} and \textit{RDFNode}, and the triples the appear in the resulting dataset multiple times trough to the hierarchical data structure are represented with the class \textit{MultiTriple}. 

The implemented framework takes the descriptor dataset, which is currently set of Java objects, and the processes it in order to generate further descriptor objects of both for the client and the server. These generated descriptor objects are such datasets that contains additional information regarding the functionality, that are not directly defined in the original descriptor. 

\img{\III}{332_1.png}{Framework functionality outline}{ss2}

The form descriptor data is a JSON object containing the definition of the form elements including the sub forms, and data dependencies between the selector fields, so that it can get the options of the sub selectors dynamically. The essence of the routines running on the client is to convert the descriptor JSON object into the form fields, and initiate the necessary AJAX calls.

The server has three main tasks, loading the form data upon the AJAX calls, convert the submitted JSON object to the RDF data, and retrieve the stored data by the edition. The utility of the implemented framework that it exploits that the SPARQL query and the RDF datasets are both RDF graph patterns, and thus they both can be generated automatically from the triple definition part of the descriptor dataset. This feature enable a more compact data definition then what is required in the current VIVO framework.

