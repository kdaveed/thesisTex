\chapter{Problem Statement}

\section{Challanges of the RDFBones project}

\subsection{Human skeleton}

The subject of the anthropological investigations is primarily human skeletal remains. To be able to create data about these remains, first of all an ontology is required. As the human skeleton is complex, the ontology is not developed by us, but an existing have been taken. The used ontology is the subset of FMA (Foundation Model of Anatomy) ontology. For us the two most important classes are the following: 

\begin{itemize}
	\item Subdivision of skeletal system - fma:85544  
	\item Bone Organ – fma:5018
\end{itemize}

The class Bone Organ is the superclass of all bones in the human skeleton.  Each bone belongs to a skeletal subdivision and a skeletal subdivision can be a part of another skeletal subdivision. This relationship in both case is expressed by the property fma:systemic\_part\_of. To define which bone organ belongs to which skeletal subdivision FMA uses OWL restrictions.

\imgK{\III}{1ontologyStructure.png}{Ontology structure for skeleton}

The most important skeletal subdivision for our project is the skull. Skull has the peculiarity that it consists not directly of bones but two of other subdivisions, which consists of the Bone Organ subclasses.

%
\imgK{\III}{skullScheme.png}{FMA scheme for skull} 

The following image illustrates then the data structure of skull.

\imgK{\III}{rdfSkull.png}{RDF Triple representation of a skull} 

To implement an entry form that allows the user to create such triple set takes considerably more effort then the cases explained in the previous sections, because not only key value pairs has to be sent from the client to the server, but a multi dimensional dataset. 

\subsection{Ontology Extensions}

It is often the case that in an investigation not only the bone itself, but also particular segments has to be addressed. However the bone segments of the bones are not standard, and they can differ according to researcher or research project. Therefore FMA do not contain any bone segment of the bone organs, and consequently we have to define it on our own. 
Important that the skeletal subdivision instances do not appear on the dataset on their own, but they are connected to Skeletal Inventories. Skeletal inventories are used to gather information about particular skeletal remains.  The following image show the triple structure of skeletal inventories.

\imgK{\III}{skelInv.png}{Skeletal Inventory Data Structure} 

The variable ?skeletalInventory is the instance of the class rdfbones:SkeletalInventory, while the ?boneSegment is from the class rdfbones:SegmentOfSkeletalElement. The core ontology of the project contains a subclass of the rdfbones:SkeletalInventory, the rdf:PrimarySkeletalInventory. This skeletal inventory type is for skeletal remain collections where only the whole bone organs have to be addressed.  The way to define custom bone segments is always through a custom skeletal inventories, which contains restrictions on the property obo:isAbout and on the class of custom bone segments. Of course the custom bone segments has to be assigned to the bone organ class they belong to, via restrictions on property obo:systemic\_part\_of. The following image illustrates the extension definition.

\imgK{\III}{ontExtScheme.png}{Ontology extension scheme}

As these extensions are expressed by OWL restriction the application can query the definitions. Consequently if the custom entry form is called from the profile of a skeletal inventory instance, then the entry form processor routine can ask, what bone segment are defined to the type of the subject variable coming as input, and can offer them on the interface.

\subsection{Study Design Execution}

In most investigations the researcher take a set of bones belong to one individual and examine different tokens. Tokens refer to specific features of parts or regions of bones. These token have particular expressions.

\imgK{\III}{glabExpressions.png}{Glabella and its expressions}

The previous images show the token called glabella, and its expressions. The task of the web application is let the researcher select one of the already added Nasal Bones (because on that bone is the glabella token), and set the expression of it. The following data structure models the process.

\imgK{\III}{studyDesEx.png}{Study Design Execution Data Structure}

Where the variable ?categoricalLabel represents the expression of the token. The values this variable can take are defined in the ontology extension. The variable ?boneSegment is the bone on which the glabella can be found. This instance won’t be as well newly created, but an already added bone has to be selected on the interface. The ?assay and the ?meausurementDatum variables are new instances.  To be able to generate an entry form for the problem, the following ontology extension has to be defined.

\imgK{\III}{extGlab.png}{Ontology extension for Glabella}


\section{RDF Data input}

\subsection{Multi dimensional form}

Imagine a problem of registering a new user to a web portal. The form offers the fields for name, e-mail address, birth, and address. The address consists of three fields, of the country city and the street-nr field. See figure~\ref{sVsM} illustrates two types of user registry form. On the left (a) there is single form, which consists of the six fields. Each field holds a literal value added by the user. However on the right (b), there is a multi dimensional form, that allows the user to add multiple addresses. The implementation of such entry form requires JavaScript routines, that dynamically loads as many subform, as many times the user clicks the add button. Moreover thus the static HTML form is not sufficient for this task, JS is responsible for the reading of the data from the elements into a JSON object. On figure~\ref{jSON_mVsM} the resulting data can be seen, where the blue box represents an array for the objects of the subform.
Figure ~\ref{userDataModel} illustrates the data model, by denoting with an additional box, that multiple addresses can be added, where the key of the array will be the string "addresses".

\img{\III}{singleVsMultiDimensionalForm.png}{Single vs. multi dimensional form}{sVsM}

\img{\III}{multiJSON.png}{JSON object for multi dimensional forms}{jSON_mVsM}

\img{\III}{multiAddressDataModel.png}{Data model}{userDataModel}


\subsection{Existing instances and dependencies}

\begin{itemize}
	\item It can be a reasonable step in order to improve the registration, to let the users not write as string, but select the country and the city of their addresses. Moreover the interface could refresh the list of cities if the country has been selected. To solve it in RDF based application, it is necessary to have instances of the class County and City, and express their relationship with i.e the predicate eq:isInCountry.
	\item The the task of the interface is to provide selectors, and refresh them according to user actions.
	\item Figure~\ref{instanceSelection} shows the updated data model, with red triple which expresses a constraint
\end{itemize}

\img{\III}{countryCityConstraint.png}{Instance selection and dependency}{instanceSelection}

\subsection{Instance browsing}

\begin{itemize}
	\item Figure ~\ref{navigator3} shows a further option for instance selection. 
\end{itemize}

\img{\III}{navigator.png}{Navigator example}{navigator3}

\begin{itemize}
	\item The implementation requires on the server side query and the grouping of the result
	\item Client side - programming the navigator window
\end{itemize}

\subsection{Sub form dependencies}
	
\subsection{Validation}
	
\subsection{Saving data}

\subsection{Editing data on the forms}












