\chapter{Problem Statement}


\section{Multi level data input}


In the previous chapter it has been discussed how can we implement simple data input forms within the VIVO framework. The simplicity of the illustrated problems lied in that the number of instances which were created through the forms was constant, in particular one, and only their types and literal attributes were set by the user through HTML input elements. 

\img{\III}{ps1.png}{Ontology and RDF triples for complex entities}{ps1}

Nevertheless there are such entities that are more complex, and they consist of several sub part, that are represented in the ontology with further classes. Such as a skeletal subdivision consists of bone organs, or a study design execution consists of assays, which consist of input bones and output data. Consequently the RDF dataset for such entities incorporates  multiple instances organized into a tree structure. \figref{ps1} shows and example ontology and an RDF dataset. The classes (ellipses) without notation are subclasses of the three main classes and their name does not play any role.

Such dataset means that the data input form has to offer such interface elements which allows the user to add the components step by step. Adding a component means in term of the form that a new sub form appears where in the simplest case its type and label can be set.

\img{\III}{ps2.png}{Multi level form}{ps2}

\figref{ps2} shows the layout of the form for multi level data. The additional element is the button for adding the components. The dotted rectangle stands for the container element that encompasses the sub forms. To realize such functionality a JavaScript routine is needed that adds the sub forms and put the data set by the user into a JSON object. The difference compared to the key-value pairs generated by the HTML \textit{<form/>} tag, is that 
in this case the form data contains arrays to store the dynamically added elements. So JavaScript by each addition of sub component, creates a new data object and pushes into the appropriate arrays. The data of the added object will be values from the sub form. This is the basic principle how the multi level data is being created on the form. Listing \ref{multiData} shows the JSON object generated during by form from \figref{ps2}, where the objects are surrounded with ("\{\}"), while the arrays with ("[]"). After the submission the server has to process this object by iterating through the arrays of the objects, and generate the appropriate RDF triples.

\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={Multi level form data in JSON}, label=multiData, captionpos=b, belowskip=1em, aboveskip=2em]
{	type : "eq:elementA",
	label : "Element_4391",
	components : [
		{ type : "eq:componentA1",
		  label : "Component_8531",	
		  subComponents : [ { ... } ],
		},{ 
			... 
		}]
}
\end{lstlisting}


Further challenge is that the options of the type selector on the sub forms, are dependent on the selected type of the parent form (the form which the sub form has been added from). This means that the client has to load asynchronously the values, by sending AJAX request containing the selected type value to server. The task of the server is to perform the query that retrieves the classes defined through restrictions in the ontology. The goal of this functionality is firstly to ensure that only such data is created that conforms to the rules defined in the ontology, secondly the interface is much more usable if not all the components are listed, just the ones that are belong to the selected element. Moreover in this way the validation on the server after submission can be omitted.

Finally important part of problem is the editing of the data. The first step by the editing is the restore the submitted data and send to the client. In the previous chapter we have seen that it is currently solved by defining  SPARQL queries that retrieves the form variables. But since the form data is not just a set of key value-pairs but a multi level data object, this approach is not sufficient. An algorithm is required that generates the multi level JSON object from the existing triples iteratively. Furthermore after the arrival of the existing data to the client, an other routine has to reset the state of the form with the appropriate sub forms and certain selector options as well.


This section gave an insight into challenges of the multi level data input. The emphasis lied on that these problem require more complex form functionality and server algorithm. For such cases unfortunately VIVO does not provide any libraries or option for some declarative definition, thus these advanced forms has to be implemented almost from scratch, and poorly documented parts of the source code have to be understood.


\section{Solution scheme}

The aim of the thesis is to develop a web application framework that allows the definition of input processes on high level declarative way. This means that the application development, which normally incorporates coding in HTML, JavaScript and Java, is reduced to the creation of simple descriptor dataset defining the form layout and the RDF dataset that has to be created.

The first task is to design a vocabulary that models the whole data input process. This vocabulary is the scheme of the descriptor dataset. The vocabulary, like an ontology contains the classes representing the entities of the problem domain, and their relationships and attributes.

\img{\III}{dl.png}{Classes and relationships of the vocabulary}{ss1}

\figref{ss1} depicts the main classes of the vocabulary with ellipses, and the relationships with arrows. The attributes and some further subclasses are not displayed here, for the sake of readability, but they will be covered in the following chapter. The three classes on the left models the interface, and the other three on the right in turn are for the data model. The most important class is the \textit{Form} that contains the form elements. To achieve the multi level layout explained in the previous section the vocabulary contains a form element \textit{SubformAdder}, to which a sub form can be defined with the \textit{subForm} relationship. The connection between the form and data is expressed by the \textit{represents} relationship. The whole data model is built up of triples, that have of course subject and object nodes. In the data modelling the concepts multi level data is expressed wuth the class \textit{MultiTriple}. 

The second task is to implement the libraries both on the server and client side that is capable of operating dynamically on descriptor objects. The workflow starts with the processing of the configuration dataset. This have three main task, the validation of the input data, and the generation of the descriptor objects for the server and the client.


\img{\III}{332_1.png}{Framework functionality outline}{ss2}

The form descriptor data is a JSON object containing the definition of the form elements including the sub forms, and data dependencies between the form elements, so that it can get the options of the sub selectors dynamically. The essence of the routines running on the client is to convert the descriptor JSON object into the form fields, and initiate the necessary AJAX calls.

The server has three main tasks, loading the form data upon the AJAX calls, convert the submitted JSON object to the RDF data, and retrieve the stored data by the edition. These operations requires SPARQL queries and RDF triple strings, which all is generated automatically from the dataset descriptor object.

