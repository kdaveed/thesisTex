\chapter{Problem Statement}

The first section discusses the problem in a general way by addressing the challenges of the implementation both for the client and the server side in case of more elaborate data input processes. The second section, in turn, refers to the use-cases of the \textit{RDFBones} project and to the limitations of the VIVO framework. Finally, the third part introduces the main elements of descriptor logic and gives and insight into the functionality of the developed system. 

\section{Multi level data input}

In the previous chapter it has been discussed how can we implement simple data input forms within the VIVO framework. The simplicity of the illustrated problem lied in that the number of instances which were created through the process was constant, in particular, one, and only a set of literal attributes were set by the user through HTML input elements. Nevertheless, there are more complex entities consisting of several subparts, where these subparts are represented in the ontology with further classes. Consequently, the RDF dataset for such entities incorporates multiple instances organized into a tree structure. \figref{ps1} shows an example ontology and an RDF dataset. The classes (ellipses) without notation are subclasses of the three main classes and their names are not relevant.

\img{\III}{ps1.png}{Ontology and RDF triples for complex entities}{ps1}

Such dataset poses the requirement for the input form, that the user has to be offered such interface elements which enable to add the components and subcomponents step by step. Adding a component means in terms of the form, that a sub form has to appear which contains further input fields for the component instances.

\img{\III}{ps2.png}{Multi level form}{ps2}

\figref{ps2} shows the layout of the form for multi-level data. The additional element compared to the static HTML form is the field with a button for adding the sub forms. The dotted rectangle stands for the element which encompasses the added sub forms. The form data contains the same way the key-value pairs for the main form element, but it has an additional key, where the value is an array of the data objects of the sub forms. The sub form data object works the same way, if it has sub forms then it contains further arrays. To realize such functionality, JavaScript routine is required on the form, that adds the sub form elements to the container, and generates the appropriate form data upon the user actions. Listing \ref{multiData} shows the JSON object generated by the form from \figref{ps2}, where the objects are surrounded with ("\{\}"), while the arrays with ("[]"). After the submission, the server has to process this object by iterating through the arrays of them and generate the appropriate RDF triples.

\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={Multi level form data in JSON}, label=multiData, captionpos=b, belowskip=1em, aboveskip=2em]
{	type : "eq:elementA",
	label : "Element_4391",
	components : [
		{ type : "eq:componentA1",
		  label : "Component_8531",	
		  subComponents : [ { ... } ],
		},{ 
			... 
		}]
}
\end{lstlisting}

A further challenge for the client algorithm is that the options of the selectors for the component type on the subforms are dependent on the selected type on the parent form (the form which the subform has been added from). This means that the client has to load asynchronously the values, by sending an AJAX request containing the selected type value to the server. The task of the server is to perform the query that retrieves the classes defined through restrictions in the ontology and to return the results. The aim of this functionality is first to ensure that only such data is created that conforms to the rules defined in the ontology, secondly, the interface is much more usable if not all the component classes are listed, just the ones that belong to the selected element class. Moreover, in this way, the validation on the server side after the submission can be omitted.

Finally, really important part of the problem is the editing of the existing data. By editing, the application has to restore the state of the form, in which it has been initially submitted. But since the form data is in this case, not just a set of key-value-pairs but a multi-level data object, an algorithm is required that generates the multi-level JSON object from the existing triples iteratively. Then another routine on the client has to reset the state of the form with the appropriate subforms and certain selector options as well based on the arrived data. Moreover, both the client and the server has to be able to handle deletion of the particular subforms, which is done through AJAX.

\section{RDFBones use-cases in VIVO}

In VIVO the data input problems were solved using static HTML forms written with \textit{FTL} macros, and defining the graph pattern and variable types by assigning values of the fields of a certain Java class, based on which a generic algorithm creates and retrieves the data. \figref{rdfBones1} and \figref{rdfBones2} illustrate the graph pattern and the multi-level form layout of the two most important cases of the \textit{RDFBones} project. 

\img{\III}{rdfBones1.png}{Skeletal subdivision graph pattern and form layout}{rdfBones1}

\img{\III}{rdfBones2.png}{Investigation graph pattern and form layout}{rdfBones2}

The problem is that it would be necessary to define custom JavaScript routines for each case, which adds the subforms and handles the dependencies between the particular selector fields because the FTL library is not able to designed to handle the dynamic events. Moreover, since VIVO cannot process the multi-level JSON object coming from the client based on a single, triple pattern in a string, for each case an individual Java routines have to be written that creates the data, as well as for the retrieval. Furthermore, the individual variables in the triple pattern do not appear only once in the result dataset. Thus their value cannot be defined with a single SPARQL query for the data retrieval. 

\section{Solution scheme}

The idea of the thesis is to allow the declarative definition of the multi-level data input cases, in such a way that VIVO allows it for the static ones so that the various problems could be solved without writing individual Java and JavaScript routines. This is achieved by an additional set of descriptor Java classes and routines both on the client and the server side, which are capable of interpreting the extended descriptor objects.

Important difference wrt. VIVO that the scheme of the forms is defined through Java objects not in FTL files. The two main classes are the \textit{Form} and the \textit{FormElement}. There are subclasses of the \textit{FormElement} class, which represent the different types of an input field. The form element that allows the definition of the multi-level form is the \textit{SubformAdder} class. From the Java objects describing the multi-level layout, a JSON object is generated, which is interpreted by a JavaScript library, which generates the form and manages the functionality.

In the data definition, the most fundamental improvement is that the triple pattern is not expressed as a string but as a set of different types of the triple. The three main types of triple are the \textit{Triple}, the \textit{MultiTriple} and the \textit{RestrictionTriple}. The \textit{Triple} has the same role as a triple substring in VIVO, while the \textit{MultiTriple} allows the expression of the hierarchy in the graph pattern, which presents on the form as well. With the \textit{MultiTriple} the submission handler routine is prepared that a set of variables do not appear as single values in the form data, but within further objects in an array. Likewise, in the other direction by the data retrieval the \textit{MultiTriple} is the basis of the multi-level form data JSON object generation. The \textit{RestrictionTriple} is used to express dependencies between classes in the graph pattern, which is relevant for the client. \figref{solutionScheme} depicts the extended graph pattern definition for the general case, where the restriction triple are depicted with the red arrow and the multi triple with the double line arrow.

\img{\III}{solScheme.png}{Extended RDF graph pattern definition}{solutionScheme}

Above the data generation based on the graph pattern, an important utility of the Java library on the server the is capable of generating the SPARQL queries both for the data retrieval and for the data dependencies on the form, thus allowing more compact definition. Finally, an image is provided to illustrate the main elements and mechanisms of the implemented framework.

\img{\III}{332_1.png}{Framework functionality outline}{frameworkFunctionality}
