\chapter{Problem Statement}


\section{Multi level data input}


In the previous chapter it has been discussed how can we implement simple data input forms within the VIVO framework. The simplicity of the illustrated problems lied in that the number of instances which were created through the forms was constant, in particular one, and only their types and literal attributes were set by the user through HTML input elements. 

\img{\III}{ps1.png}{Ontology and RDF triples for complex entities}{ps1}

Nevertheless there are such entities that are more complex, and they consist of several sub part, that are represented in the ontology with further classes. Such as a skeletal subdivision consists of bone organs, or a study design execution consists of assays, which consist of input bones and output data. Consequently the RDF dataset for such entities incorporates  multiple instances organized into a tree structure. \figref{ps1} shows and example ontology and an RDF dataset. The classes (ellipses) without notation are subclasses of the three main classes and their name does not play any role.

Such dataset means that the data input form has to offer such interface elements which allows the user to add the components step by step. Adding a component means in term of the form that a new sub form appears where in the simplest case its type and label can be set.

\img{\III}{ps2.png}{Multi level form}{ps2}

\figref{ps2} shows the layout of the form for multi level data. The additional element is the button for adding the components. The dotted rectangle stands for the container element that encompasses the sub forms. To realize such functionality a JavaScript routine is needed that adds the sub forms and put the data set by the user into a JSON object. The difference compared to the key-value pairs generated by the HTML \textit{<form/>} tag, is that 
in this case the form data contains arrays to store the dynamically added elements. So JavaScript by each addition of sub component, creates a new data object and pushes into the appropriate arrays. The data of the added object will be values from the sub form. This is the basic principle how the multi level data is being created on the form. Listing \ref{multiData} shows the JSON object generated during by form from \figref{ps2}, where the objects are surrounded with ("\{\}"), while the arrays with ("[]"). After the submission the server has to process this object by iterating through the arrays of the objects, and generate the appropriate RDF triples.

\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={Multi level form data in JSON}, label=multiData, captionpos=b, belowskip=1em, aboveskip=2em]
{	type : "eq:elementA",
	label : "Element_4391",
	components : [
		{ type : "eq:componentA1",
		  label : "Component_8531",	
		  subComponents : [ { ... } ],
		},{ 
			... 
		}]
}
\end{lstlisting}


Further challenge is that the options of the type selector on the sub forms, are dependent on the selected type of the parent form (the form which the sub form has been added from). This means that the client has to load asynchronously the values, by sending AJAX request containing the selected type value to server. The task of the server is to perform the query that retrieves the classes defined through restrictions in the ontology. The goal of this functionality is firstly to ensure that only such data is created that conforms to the rules defined in the ontology, secondly the interface is much more usable if not all the components are listed, just the ones that are belong to the selected element. Moreover in this way the validation on the server after submission can be omitted.

Finally important part of problem is the editing of the data. The first step by the editing is the restore the submitted data and send to the client. In the previous chapter we have seen that it is currently solved by defining  SPARQL queries that retrieves the form variables. But since the form data is not just a set of key value-pairs but a multi level data object, this approach is not sufficient. An algorithm is required that generates the multi level JSON object from the existing triples iteratively. Furthermore after the arrival of the existing data to the client, an other routine has to reset the state of the form with the appropriate sub forms and certain selector options as well.


This section gave an insight into challenges of the multi level data input. The emphasis lied on that these problem require more complex form functionality and server algorithm. For such cases unfortunately VIVO does not provide any libraries or option for some declarative definition, thus these advanced forms has to be implemented almost from scratch, and such parts of the source code have to be understood that are poorly documented.


\section{Solution scheme}

The task of the implementation of a data input forms addresses two main questions. Firstly is what dataset has to be created, and secondly how this dataset is represented on the form. The vocabulary which is capable
of defining the whole input process, has to be able to answer both these question. Therefore the model is divided into two sections, to the data definition and the form definition. The data definition consist of a set of RDF nodes and triples, while the interface definition consist of the forms and the data input fields. Nevertheless we have the previous chapters we have seen that the scheme of the ontology plays an important role of the data entry form process. Namely if a set restriction statement assign multiple classes to one, like i.e. bone organs to a skeletal subdivisions, then the web user interface has to
be adapted to this scheme, and it has to of the possibility to add sub forms dynamically. So to make the vocabulary complete is it inevitable to expresses
what triples may be added multiple times and of which form elements adds further sub forms.

\img{\III}{dl.png}{Classes and relationships of the vocabulary}{ss1}

\figref{ss1} shows the main elements and relationships of the vocabulary. It can be seen that the connection between the data and the form definition is established through the represents predicate that connects form elements to RDF nodes. Moreover the MultiTriple is a subclass of the class \textit{Triple}, and it that allows to expresses the scheme of the ontology subset, for which the RDF data will be created.

The idea is that framework operates completely upon this definition. The first task is to process the definition and generate JSON objects that describes the forms layout, and further Java objects for the data operations.

\img{\III}{332_1.png}{Framework functionality outline}{ss2}

