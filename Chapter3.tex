\chapter{Problem Statement}

\section{Modeling anthropological research activity}

This section is based on section \ref{ontologies}, but it addresses the RDFBones ontology, developed by the colleagues. The rough discussion of the RDFBones ontology is inevitable to understand the software problems of the project. 



\subsection{Data on skeletal remains}


We have seen in the section \ref{fma} the base structure of the human skeleton. The most important point is that not only individual bones will be represented in the data we create, but the skeletal regions as well, like skull or vertebral column. The instutute where these investigations are conducted posses mainly skull skeletal remains. The skull has the peculiarity that it consist of not directly of bones, but from two sub skeletal division, and these to subdivisions contain the bones. Figure \figref{tripleSkull} following image show the ontology subset for the skull and the data instances (each denoted with \#). The red arrows denotes restrictions on the properties \textit{fma:systemic\_part\_of}.  

\img{\III}{rdfSkull.png}{Ontology and triples of the skull}{tripleSkull} 

So we know how skull and it subdivision and bone organs are represented by RDF but, there are processes where specific bone segments have to be addressed as well. To to be able to express this, RDFBones have the class \textit{rdfbones:SegmentOfSkeletalElement}. This instances of this class is connected to the instances of the class \textit{Bone Organ} with the property \textit{fma:regional\_part\_of}. 

\img{\III}{rdfBonesCard.png}{Bone segment in RDFBones}{rdfBonesCard} 



Furthermore these instances referring to skeletal remain do not stay in the database individually. If a researcher takes a specific skull from the collection of the institute it makes a so-called skeletal inventory, which records what bones are present in the skull. The information about the presence is stored in further instance called \textit{Completeness 2 states}.  


\img{\III}{core.png}{RDFBones as extension of OBI}{rdfBonesCard} 




\begin{lstlisting}[captionpos=b, caption= data representing skull, label=skullJSON,
basicstyle=\footnotesize,frame=single]
{
	skeletalSubdivisionUri : "FMA:46565",
	sytemic_parts : [{
		uri : "FMA:53672",
		systemic_parts : [{
			uri : "FMA:52788",  //Right parietal bone
		} , { ... }]
	} , { ... }
	]	
}
\end{lstlisting}


Here the really important point the not only values are added like the simple form of the previous examples, but some elements can be added or just or just leaved. This leads to more dynamic
interfaces.

\subsection{Study Design Execution}


\img{\III}{rdfBonesO.png}{RDF Triple representation of a skull}{tripleSkull} 


In most investigations the researcher take a set of bones belong to one individual and examine different tokens. Tokens refer to specific features of parts or regions of bones. These token have particular expressions.

\imgK{\III}{glabExpressions.png}{Glabella and its expressions}

The previous images show the token called glabella, and its expressions. The task of the web application is let the researcher select one of the already added Nasal Bones (because on that bone is the glabella token), and set the expression of it. The following data structure models the process.

\imgK{\III}{studyDesEx.png}{Study Design Execution Data Structure}

Where the variable ?categoricalLabel represents the expression of the token. The values this variable can take are defined in the ontology extension. The variable ?boneSegment is the bone on which the glabella can be found. This instance wonâ€™t be as well newly created, but an already added bone has to be selected on the interface. The ?assay and the ?meausurementDatum variables are new instances.  To be able to generate an entry form for the problem, the following ontology extension has to be defined.

\imgK{\III}{extGlab.png}{Ontology extension for Glabella}


Mention that the task of the user is to add some elements if they exists or not.


\subsection{Ontology Extensions}

It is often the case that in an investigation not only the bone itself, but also particular segments has to be addressed. However the bone segments of the bones are not standard, and they can differ according to researcher or research project. Therefore FMA do not contain any bone segment of the bone organs, and consequently we have to define it on our own. 
Important that the skeletal subdivision instances do not appear on the dataset on their own, but they are connected to Skeletal Inventories. Skeletal inventories are used to gather information about particular skeletal remains.  The following image show the triple structure of skeletal inventories.

\imgK{\III}{skelInv.png}{Skeletal Inventory Data Structure} 

The variable ?skeletalInventory is the instance of the class rdfbones:SkeletalInventory, while the ?boneSegment is from the class rdfbones:SegmentOfSkeletalElement. The core ontology of the project contains a subclass of the rdfbones:SkeletalInventory, the rdf:PrimarySkeletalInventory. This skeletal inventory type is for skeletal remain collections where only the whole bone organs have to be addressed.  The way to define custom bone segments is always through a custom skeletal inventories, which contains restrictions on the property obo:isAbout and on the class of custom bone segments. Of course the custom bone segments has to be assigned to the bone organ class they belong to, via restrictions on property obo:systemic\_part\_of. The following image illustrates the extension definition.


\imgK{\III}{ontExtScheme.png}{Ontology extension scheme}

As these extensions are expressed by OWL restriction the application can query the definitions. Consequently if the custom entry form is called from the profile of a skeletal inventory instance, then the entry form processor routine can ask, what bone segment are defined to the type of the subject variable coming as input, and can offer them on the interface.



\section{RDF Data input}

\subsection{Multi dimensional form}

As it was addressed in the previous section each data input process of the application can be modeled by means of a tree style data structure. This means in terms of the data of the form, that just single key-value pairs like by the static HTML form is not sufficient for the problem. Therefore the task is provide such an interface that allows the user to add dynamically subforms, whose data object will be stored in arrays. \figref{mdfl} illustrates the idea of the structure. 

\img{\III}{multiDimensionalForm.png}{Multi dimensional form layout}{mdfl}

So the forms consist of the selectors, and literalfield explained in the Chapter 1., but with an additional element that add further subforms. To achieve this JavaScript routine is required that adds the elements automatically and fills the form object with the data. The produced data of the form is looks as follows.


\begin{lstlisting}[captionpos=b, caption=JSON object of the form, label=3rd:sparql,
basicstyle=\footnotesize,frame=single]
{
	key1 : "value1",
	key2 : "value2",
	...
	subFormKey1 : [
	{
		key1_1 : "value1_1",
		...				
	}, { ... }]
}
\end{lstlisting}


\subsection{Form dependencies} \label{formDependencies}


\img{\III}{subformDependency.png}{Subform dependencies}{mdfl}

These dependencies can occur not only between subforms but as well by in form dependencies where the selector elements can change based on selections.

\subsection{Instance browsing}


\begin{itemize}
	\item Figure ~\ref{navigator3} shows a further option for instance selection. 
\end{itemize}

\img{\III}{navigator.png}{Navigator example}{navigator3}

\begin{itemize}
	\item The implementation requires on the server side query and the grouping of the result
	\item Client side - programming the navigator window
\end{itemize}


\subsection{Validation}

As by each form there is required field - required - restrictions
The client has to get the information, about restrictions, and so  


\subsection{Editing form data}
	
As it was already addressed in section \ref{vivoCef}, the dataset created by the forms have to be edited as well. By editing, the HTTP request calling the entry form contains an additional field, namely the \textit{objectUri}. Based on the data model of the form, the server has to prepare the dataset, in our case a JSON object. The challenge of the server implementation is that in such multi dimensional dataset, it is not sufficient to perform only one query for the whole form data.

\img{\III}{exampleDataModel.png}{Example data model}{exDatMod}

\begin{lstlisting}[captionpos=b, caption=SPARQL query for the form data, label={sparqlExisting},
basicstyle=\footnotesize,frame=single]
SELECT ?a ?b
WHERE {
	?objectUri		p1		?a .
	?objectUri		p2		?b .
	FILTER ( ?objectUri = <inputParameter>)
}
\end{lstlisting}

The example data model from \figref{exDatMod} helps to understand the problem in more detail. If the SPARQL query on \listref{sparqlExisting} for variables ?a and ?b with incoming \textit{objectUri} value were executed, then result table of the query is inconvenient to process. For example if there are two instances for both ?a and ?b present in the dataset, then the result table contains \textit{2 x 2 = 4} elements (\tableref{sparqlResult}).

\begin{table}

	\begin{center}
		\begin{tabular}{||c | c||} 
			\hline
			?a & ?b  \\ [0.5ex] 
			\hline\hline
			a1 & b1 \\ 
			\hline
			a1 & b2 \\
			\hline
			a2 & b1 \\
			\hline
			a2 & b2 \\ [1ex] 
			\hline 
		\end{tabular}
	\end{center}
	\caption{SPARQL Result}  \label{sparqlResult}
\end{table}


Therefore the data object of the form has to be retrieved gradually, by dividing the data model graph by the predicates, whose cardinality is larger than one.

The next step after that the server has prepared the multi dimensional JSON object for the client, is to restore the state of the form, in which it was submitted by the user. This requires firstly the filling of the fields with the existing values, and adding the sub forms based on the arrays. Secondly the options of the selectors must be loaded, so that they conform to the dependencies explained in section \ref{formDependencies}. 

Finally if a value of selector or literal field changes, or new sub forms has to be added or removed, the entry form data should not be completely sent again to the server, but only the data fields that are concerned by the modification. Thus it does not require a complete page reload, and these operation can be performed through AJAX calls. To achieve this the client has to be prepared to be able to send data modification requests to the server on change event of any form element or sub form.

\subsection{Saving data}













