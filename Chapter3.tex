\chapter{Problem Statement}

The first section discusses the problem general in a way by addressing the challenges of the implementation both for the client and the server side in case of more elaborate data input processes. The second section in turn refers to the use-cases of the \textit{RDFBones} project and to the limitations of the VIVO framework. Finally, the third part introduces the main elements of descriptor logic and gives and insight into the functionality of the developed system. 

\section{Multi level data input}

In the previous chapter it has been discussed how can we implement simple data input forms within the VIVO framework. The simplicity of the illustrated problem lied in that the number of instances which were created through the process was constant, in particular one, and only a set of literal attributes were set by the user through HTML input elements. Nevertheless there are more complex entities consisting of several sub parts, where these sub parts are represented in the ontology with further classes. Consequently the RDF dataset for such entities incorporates multiple instances organized into a tree structure. \figref{ps1} shows and example ontology and an RDF dataset. The classes (ellipses) without notation are subclasses of the three main classes and their names are not relevant.

\img{\III}{ps1.png}{Ontology and RDF triples for complex entities}{ps1}

Such dataset poses the requirement for the input form, that the user has to be offered such interface elements which enable to add the components and subcomponents step by step. Adding a component means in terms of the form, that new sub forms have to appear which contains further input fields for the component instances.

\img{\III}{ps2.png}{Multi level form}{ps2}

\figref{ps2} shows the layout of the form for multi level data. The additional element compared to the static HTML form is the field with an button for adding the sub forms. The dotted rectangle stands for the element which encompasses the added sub forms. The form data contains the same way the key value pairs for the main form element, but it has an additional key, where the value is an array for the data objects of the sub forms. The sub form data object works the same way, if it has sub forms then it contains further arrays. To realize such functionality, JavaScript routine is required on the form, that adds the sub form elements to the container, and generates the appropriate form data upon the user actions. Listing \ref{multiData} shows the JSON object generated during by form from \figref{ps2}, where the objects are surrounded with ("\{\}"), while the arrays with ("[]"). After the submission the server has to process this object by iterating through the arrays of them, and generate the appropriate RDF triples.

\begin{lstlisting}[basicstyle=\footnotesize, frame=single, caption={Multi level form data in JSON}, label=multiData, captionpos=b, belowskip=1em, aboveskip=2em]
{	type : "eq:elementA",
	label : "Element_4391",
	components : [
		{ type : "eq:componentA1",
		  label : "Component_8531",	
		  subComponents : [ { ... } ],
		},{ 
			... 
		}]
}
\end{lstlisting}

Further challenge for the client algorithm is that the options of the selectors for the component type on the sub forms are dependent on the selected type of the parent form (the form which the sub form has been added from). This means that the client has to load asynchronously the values, by sending AJAX request containing the selected type value to server. The task of the server is to perform the query that retrieves the classes defined through restrictions in the ontology and to return the possible options. The aim of this functionality is firstly to ensure that only such data is created that conforms to the rules defined in the ontology, secondly the interface is much more usable if not all the component classes are listed, just the ones that belong to the selected element class. Moreover in this way the validation on the server side after the submission can be omitted.

Finally, really important part of the problem is the editing of the existing data. By editing the application has to restore the state of the form, in which it has been initially submitted. But since the form data is in this case not just a set of key value-pairs but a multi level data object, an algorithm is required that generates the multi level JSON object from the existing triples iteratively. Then other routine on the client has to reset the state of the form with the appropriate sub forms and certain selector options as well based on the arrived data. Moreover both the client and the server has to be able to handle deletion of the particular sub forms, which is done through AJAX.

\section{RDFBones use-cases in VIVO}

In VIVO the data input problems were solved by means of a static HTML forms written with \textit{FTL} macros, and defining the graph pattern and variable types by assigning values of the fields of a certain Java class, based on which a generic algorithm creates and retrieves the data. \figref{rdfBones1} and \figref{rdfBones2} illustrate the graph pattern and the multi level form layout of the two most important cases of the \textit{RDFBones} project. 

\img{\III}{rdfBones1.png}{Skeletal subdivision graph pattern and form layout}{rdfBones1}

\img{\III}{rdfBones2.png}{Investigation graph pattern and form layout}{rdfBones2}

The problem is that it would be necessary to define custom JavaScript routines for each case, which adds the sub forms and handles the dependencies between the particular selector fields, because the FTL library does not able to designed to handle the dynamic events. Moreover since VIVO cannot process the multi level JSON object coming from the client after the submission based on a single triple pattern in a string, for each case an individual Java routines have to be written that creates the data, as well as for the retrieval. Furthermore the individual variables in the triple pattern do not appear only once in the result dataset, thus their value cannot be defined with SPARQL a single queries. 

\section{Solution scheme}

The idea of the thesis is to allow the definition of the multi level data input cases, in a such way that VIVO allows it for the static ones, so that various problem could be solved without writing individual Java and JavaScript routines. This is achieved by an additional set of Java classes, whose instances are capable describing the problems, and additional routines both on the client and the server side which are capable of interpreting the extended descriptor data.

Important difference wrt. VIVO that the scheme of the forms are defined as well through Java objects not in FTL files. The two main classes are the \textit{Form} and the \textit{FormElement}. There are subclasses of the \textit{FormElement} class, which represents the different input fields. The form element that allows the definition of the multi level form is the \textit{SubformAdder} class. From the Java objects describing the multi level layout, a JSON object is generated, which is interpreted by a JavaScript library, that generates the form and manages the functionality.

In the data definition the most fundamental improvement is that the triple pattern is not expressed as a string but as a set of different types of triple. The three main types of triple are the \textit{Triple}, the \textit{MultiTriple} and the \textit{RestrictionTriple}. The \textit{Triple} has the same role as a triple substring in VIVO, while the \textit{MultiTriple} allows the expression of the hierarchy in the graph pattern, which presents on the form as well. With the \textit{MultiTriple} it is possible to prepare the submission handler routine that a set of variables are not appear as single values in the form data, but within further objects in an array. \textit{RestrictionTriple} is used to express dependencies between classes in the graph pattern. This definition is used to generate the SPARQL queries that return the options of the dependent variables. \figref{solutionScheme} depicts the extended graph pattern definition, where the restriction triple are depicted with red arrow, and the multi triple with double line arrow.

\img{\III}{solScheme.png}{Extended RDF graph pattern definition}{solutionScheme}

\figref{frameworkFunctionality} depicts the scheme of the functionality. The most important improvement that there is processor that is capable of inferring some additional data object from the original descriptor objects. This allows more compact definition of the processes.

\img{\III}{332_1.png}{Framework functionality outline}{frameworkFunctionality}
