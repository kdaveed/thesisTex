\chapter{Vocabulary for RDF data input}

The aim of this chapter is show how can different data input problems be expressed through the instantiation of specific set of Java classes. At first the elements of the vocabulary is discussed briefly, then the solved two use-cases of the RDFBones project are presented.

\section{Elements of the vocabulary}

\subsection{Data definitions}

The first part of the vocabulary relates to the RDF data definition. The two main classes for this purpose are the \textit{Triple} and the \textit{RDFNode}. Both of them have different subclasses for the custom cases. \figref{voc1} shows the UML class diagram for the different types of node, and \figref{voc2} in turn depicts the classes for the triples.

\img{\IV}{voc1.png}{Java classes for RDF nodes}{voc1}

The class diagram does not contain all the fields and methods for the sake of simplicity. The most important field is the \textit{variableName}, based on which the form elements can reference the nodes. In the data definition constant classes can appear, for this stands the class \textit{Constant}. In the vocabulary there are two specific classes for the input nodes. The first is the \textit{MainInputNode}, which represent the variables, that are coming with initial form call. In VIVO these are always the \textit{subjectUri}, the \textit{predicateUri} and the \textit{rangeUri}. The class \textit{FormInputNodes} stands for the variables that appear on the form.

\img{\IV}{voc2.png}{Java classes for RDF triples}{voc2}

In the class \textit{Triple}, the three most relevant fields are the \textit{subject}, the \textit{object} and the \textit{predicate}. The first two have the type \textit{RDFNode}, while the predicate is always a constant string. The role of the class \textit{MultiTriple} were already discussed the previous chapter. The \textit{LiteralTriple} plays only a role in the advanced instance selector interface (discussed in more detail later), because currently the system is not capable of creating literal triples above the labels of the instances. There are two types of restriction triple, one for the classes, the class \textit{RestrictionTriple}, and the other for the instances, the class (\textit{InstanceRestrictionTriple}. The usage of the latter will be discussed in section \textit{43}. The former is for the restrictions defined with \textit{owl:someValuesFrom} and \textit{owl:allValuesFrom} properties, while its subclass the \textit{QualifiedRestrictionTriple} represents the qualified restriction triples. The last restriction triple, the \textit{GreedyRestrictionTriple} stands for the cases where the query on the restrictions has to check there are restrictions applied not only directly on the input class, but on its super classes as well.

\subsection{Form definition}

As it was already mentioned in the previous chapter the two main classes for the form layout definition are the \textit{Form} and the \textit{FormElement}. The form has a title as a string and contains the different form elements in its field \textit{formElement}. 

\img{\IV}{voc3.png}{Java classes for the form}{voc3}

In the class \textit{FormElement} the most important field is the dataKey, which is holds the variable name for the RDF node it represents. The form element \textit{SubFormAdder} has a field \textit{Form}, which allows the sub form definition. The class \textit{LiteralField} stands for an element, which allows to define the prefix for the labels of all instances created newly through the data input process. Here it is important to note that on the forms implemented for the project, it has to be possible to let the user selecting existing instances, which will contribute to the resulting dataset. The class \textit{Selector} stands for the HTML selector element, which allows the definition selection both of instances and classes on the form. The class \textit{InstanceSelector} denotes a such field where the existing instance can be selected through a floating window implemented in JavaScript. This window allows tp display more information, by displaying the instances within a table where the different columns contains data about them. This table, its cells and triples for the additional SPARQL query by the classes depicted on \figref{voc4}. Finally, the class \textit{AuxNodeSelector}, allows the selection of such instances on the form, who does not contribute to the resulting dataset, just they help to filter the instance for the other instance selectors.

\img{\IV}{voc4.png}{Java classes for instance viewer}{voc4}

\section{Use-cases of the \textit{RDFBones} project}

The aim of this section is to show how it is possible to solve different problems with designed vocabulary. It covers the two main tasks of the project, the skeletal inventories and the study design execution. These two examples are sufficient to show the utility of the particular elements in the vocabulary and exemplify how their assembly can lead to a compact definition of complex web application problems.

\subsection{Primary Skeletal Inventory}

Skeletal inventories were already addressed in section \ref{331}. To be able understand the software specification it is inevitable to go into details of extension definition  The primary skeletal inventory is the main extensions of the RDFBones project, and has the peculiarity that it does not contain any custom bone segments, but refers all of them as entire bones. For this purpose there is a class called \textit{EntireBoneOrgan}, which has as many subclass for the particular bones as many bone organ classes have been taken from the FMA ontology. The entire bone organs and normal bone organs the connected through restriction on the property \textit{fma:regional\_part\_of}. Moreover for each entire bone organ a custom completeness datum class is assigned, which acts as connector between the primary skeletal inventory class and the entire bone classes. 

\img{\IV}{useCase1.png}{Primary skeletal inventory extension}{primSkelInv}

\figref{primSkelInv} depicts the scheme of the primary skeletal inventory extension. The \textit{X} and \textit{Y} represent the different bone organs classes as examples. Important to note the class \textit{CompletenessTwoStatesLabel}  has two instances, which appear in all skeletal inventory dataset.

The most important skeletal region in the Biological Anthropology Department is the skull, so in the following the data input for the skull will be discussed. The skull does not consist directly of bone organs, but of two sub two subdivisions. A primary skeletal inventory for a skull is represented with the following triple pattern: 

\img{\IV}{SI_DATA.png}{Skeletal inventory data triples}{SI_DATA}

The classes of the pattern are not represented, because the main scope of the image is to illustrate the necessity of the single and multi triple in the definition. As it was address the subdivision (in our case skull) consists of multiple sub subdivision, where all consists of multiple bone organs. However each bone organ has only one bone segment, and one categorical measurement datum and category label.

Before showing how the problem is defined by the descriptor instances, the implemented interface is discussed (\figref{SI_UI}). Under the title of the a form a sub form adder element can be seen. In our implementation the subform adder is selector as well, which eliminates the type selector on the sub form, and makes the layout more compact. It can be seen the added sub form has a title, which the label of the added class for the element.

Next to the selector the buttons \textit{Add} and \textit{Add all} can be seen, that let the user add the sub forms. \figref{SI_UI} shows the layout, when two sub sudivision were added, to each of them, a bone organ. The bone organ selector works exactly the same as the sub sudvision selector, but the selector for the completeness state is simple selector, without a sub form. 
Next to the selector the buttons \textit{Add} and \textit{Add all} can be seen, that let the user add the sub forms. \figref{SI_UI} shows the layout, when two sub sudivision were added, to each of them, a bone organ. The bone organ selector works exactly the same as the sub sudvision selector, but the selector for the completeness state is simple selector, without a sub form. 



Above the instances to be created the classes have to be represented in the model too, because they can be the subjects of the class restriction triples.
 Figure \figref{SI_DATA_C} is depicts the complete data model of the problem.

\img{\IV}{SI_DATA_C.png}{Complete data definition}{SI_DATA_C}

For the better readability the predicates are not denoted, but their value can be found in figure \figref{SI_DATA}. Each instance (rectangles) is connected to the class variable (ellipses). The red dotted arrows indicates restriction statements. The large th

\img{\IV}{SI_FORM.png}{UML object diagram for form layout definition}{SI_FORM}
s


ee rectangles, that encompass set of triples are the graph, which are connecting to each other by means of multi triples. This is the structure which is followed by the form as well.


Above the auxililiary rectangles for the graph,the nodes are colored to indicate their role in the process. The information that the colors hold is not defined in the vocabulary but it can be inferred from the whole data and form model. The first rule is that the main input nodes (\textit{subjectUri} and \textit{rangeUri}) are deno
Above the auxililiary rectangles for the graph,the nodes are colored to indicate their role in the process. The information that the colors hold is not defined in the vocabulary but it can be inferred from the whole data and form model. The first rule is that the main input nodes (\textit{subjectUri} and \textit{rangeUri}) are denoted with red, while the variables appear on the interface are light red. Base on that information is it already possible to determine to which instances it is required to assign an unused URI. Those instance are denoted with yellow.
ted with red, while the variables appear on the interface are light red. Base on that information is it already possible to determine to which instances it is required to assign an unused URI. Those instance are denoted with yellow.
ted with red, while the variables appear on the interface are light red. Base on that information is it already possible to determine to which instances it is required to assign an unused URI. Those instance are denoted with yellow.
ted with red, while the variables appear on the interface are light red. Base on that information is it already possible to determine to which instances it is required to assign an unused URI. Those instance are denoted with yellow.
Furthermore there are two classes in the data model that do not appear on the interface, but their values can be evaluated through SPARQL queries. These are denoted with blue. And the classes with without color, do not appear on the final dataset, but they indicates constraint on the existing instances.
Finally \figref{SI_FORM} display the configuration data describing the form structure. 


\subsection{Study Design Execution} \label{43}


The entry form for study design execution has as well the hierarchical layout like the one for skeletal inventories, but there are additionally two elements on the main form. The first is the selector from skeletal inventories. It plays a role by the selection of the bone organs as input for the assays. To each assay a set bone segment types is defined in the extensions, that can be can be assigned to them as input. These bone on this form are not created newly but existing ones are selected, that were already added in the frame of the skeletal inventory data input.  However there can be a large amount bone segments stored in the system, and thus the search is facilitated by showing only the ones that belong to the preselected skeletal inventory. The second is a global label field, whose value will be the label of all newly created instances.




\img{\IV}{SDE_UI.png}{Input form for study design execution}{SDE_UI}

Moreover the bone segment selector is not just a HTML selector input field, but a floating window implemented by JavaScript that allows the convenient browsing (\figref{SDE_SI}). It has two advantage with respect to the conventional selector. Firstly it allows to display additional information about the instances above their labels, like their types or longer descriptions. Secondly it does not loads the form layout with additional subform for the selected instances, which by large amount assays and measurement datums is an important aspect.

\img{\IV}{SDE_IS.png}{Instance selector for existing bone segment}{SDE_SI}


On \figref{SDE_SI} can be seen that the there are two section, one for the selected instances, and one for the instances to select. 


The complete data structure of the form can be seen on the following image.

\img{\IV}{SDE_DATA_C.png}{Complete data model}{SDE_DATA_C}


