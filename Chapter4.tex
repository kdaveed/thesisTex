\chapter{Vocabulary for RDF data input}

The aim of this chapter is show how can different data input problems be expressed through the instantiation of specific set of Java classes. At first the elements of the vocabulary is discussed briefly, then the solved two use-cases of the RDFBones project are presented.

\section{Elements of the vocabulary}

\subsection{Data definitions}

The first part of the vocabulary relates to the RDF data definition. The two main classes for this purpose are the \textit{Triple} and the \textit{RDFNode}. Both of them have different subclasses for the custom cases. \figref{voc1} shows the UML class diagram for the different types of node, and \figref{voc2} in turn depicts the classes for the triples.

\img{\IV}{voc1.png}{Java classes for RDF nodes}{voc1}

The class diagram does not contain all the fields and methods for the sake of simplicity. The most important field is the \textit{variableName}, based on which the form elements can reference the nodes. In the data definition constant classes can appear, for this stands the class \textit{Constant}. In the vocabulary there are two specific classes for the input nodes. The first is the \textit{MainInputNode}, which represent the variables, that are coming with initial form call. In VIVO these are always the \textit{subjectUri}, the \textit{predicateUri} and the \textit{rangeUri}. The class \textit{FormInputNodes} stands for the variables that appear on the form.

\img{\IV}{voc2.png}{Java classes for RDF triples}{voc2}

In the class \textit{Triple}, the three most relevant fields are the \textit{subject}, the \textit{object} and the \textit{predicate}. The first two have the type \textit{RDFNode}, while the predicate is always a constant string. The role of the class \textit{MultiTriple} were already discussed the previous chapter. The \textit{LiteralTriple} plays only a role in the advanced instance selector interface (discussed in more detail later), because currently the system is not capable of creating literal triples above the labels of the instances. There are two types of restriction triple, one for the classes, the class \textit{RestrictionTriple}, and the other for the instances, the class (\textit{InstanceRestrictionTriple}. The usage of the latter will be discussed in section \textit{43}. The former is for the restrictions defined with \textit{owl:someValuesFrom} and \textit{owl:allValuesFrom} properties, while its subclass the \textit{QualifiedRestrictionTriple} represents the qualified restriction triples. The last restriction triple, the \textit{GreedyRestrictionTriple} stands for the cases where the query on the restrictions has to check there are restrictions applied not only directly on the input class, but on its super classes as well.

\subsection{Form definition}

As it was already mentioned in the previous chapter the two main classes for the form layout definition are the \textit{Form} and the \textit{FormElement}. The form has a title as a string and contains the different form elements in its field \textit{formElement}. 

\img{\IV}{voc3.png}{Java classes for the form}{voc3}

In the class \textit{FormElement} the most important field is the dataKey, which is holds the variable name for the RDF node it represents. The form element \textit{SubFormAdder} has a field \textit{Form}, which allows the sub form definition. The class \textit{LiteralField} stands for an element, which allows to define the prefix for the labels of all instances created newly through the data input process. Here it is important to note that on the forms implemented for the project, it has to be possible to let the user selecting existing instances, which will contribute to the resulting dataset. The class \textit{Selector} stands for the HTML selector element, which allows the definition selection both of instances and classes on the form. The class \textit{InstanceSelector} denotes a such field where the existing instance can be selected through a floating window implemented in JavaScript. This window allows tp display more information, by displaying the instances within a table where the different columns contains data about them. This table, its cells and triples for the additional SPARQL query by the classes depicted on \figref{voc4}. Finally, the class \textit{AuxNodeSelector}, allows the selection of such instances on the form, who does not contribute to the resulting dataset, just they help to filter the instance for the other instance selectors.

\img{\IV}{voc4.png}{Java classes for instance viewer}{voc4}

\section{Use-cases of the \textit{RDFBones} project}

The aim of this section is to show how it is possible to solve different problems with designed vocabulary. It covers the two main tasks of the project, the skeletal inventories and the study design execution. These two examples are sufficient to show the utility of the particular elements in the vocabulary and exemplify how their assembly can lead to a compact definition of complex web application problems. 

\subsection{Primary Skeletal Inventory}

Skeletal inventories were already addressed in section \ref{331}. To be able understand the software specification of the data input form it is inevitable to go a bit more into the details of extensions of the \textit{RDFBones} project. The primary skeletal inventory is the main extension and has the peculiarity that it does not contain any custom bone segments, but refers all of them as entire bones. For this purpose there is a class called \textit{EntireBoneOrgan}, which has as many subclasses for the particular bones as many bone organ classes have been taken from the FMA ontology. The entire bones are connected to the bone organs through restriction on the property \textit{fma:regional\_part\_of}. Moreover for each entire bone organ a custom completeness datum class is assigned, which acts as connector between the primary skeletal inventory class and the entire bone classes. 

\img{\IV}{useCase1.png}{Primary skeletal inventory extension}{primSkelInv}

\figref{primSkelInv} depicts the scheme of the primary skeletal inventory extension. The \textit{X} and \textit{Y} represent the different bone organs classes as examples, and \textit{E.B.O.} is the abbreviation for entire bone organ, while \textit{C2S} stands for completeness two states. Important to note the class \textit{CompletenessTwoStatesLabel}  has two instances, which is the part of the extension too, and will appear in all skeletal inventory dataset.

The most important skeletal region in the Biological Anthropology Department is the skull, so in the following the data input for the skull will be discussed. The skull does not consist directly of bone organs, but of two sub two subdivisions, so a skeletal inventory for a skull is represented with the following triple pattern: 

\img{\IV}{SI_DATA.png}{Skeletal inventory data triples}{SI_DATA}

The classes of the pattern are not shown, because the main scope of the image is to illustrate the necessity of the single and multi triple in the definition. As it was address the subdivision (in our case skull) consists of multiple sub subdivision, where all consist of multiple bone organs. However each bone organ has only one bone segment (the entire), and one categorical measurement datum and category label, and belongs to one skeletal inventory, which is represented by the \textit{subjectUri} variable.

Before showing how the problem is defined by the descriptor instances, the implemented interface is discussed (\figref{SI_UI}). Under the title of the a form a sub form adder element appears. This element is implemented so that it incorporates a class selector as well, which eliminates it on the sub form, and makes the layout more compact. It can be seen the added sub form has a title, which the label of the added class for the element. The sub form adder for the bone organs is the same. The sub form for the particular bone organs contains the selector through which the user can select if the bone is complete or partly present in the given skull.

\img{\IV}{SI_UI.png}{Generated interface for primary skeletal inventory}{SI_UI}

\figref{SI_DATA_C} depicts the complete data definition with the triples and the nodes. For the better readability the predicates are not denoted, but their value can be found in figure \figref{SI_DATA}. The predicate is always \textit{rdf:type} where the subject is an instance and the object is a class. The three rectangles denotes the three subgraphs of the graph pattern, defined through the multi triples. The pattern contains the two main input nodes (red - subjectUri, rangeUri) and three form input nodes (light red - subSubDivisionType, boneOrganType, categoryLabel). The instances depicted with yellow are normal \textit{RDFNode} instances in the vocabulary, but as they do not appear on the form their have to get new IRI after the submission. The class input nodes get their values based on the SPARQL queries generated from the restriction triples. The blue classes in turn are the classes that do not appear on the interface, but for their value has to be evaluated based on value of the incoming bone organ type for the data creation. This shows that the interface hides the complexity of the underlying data model from the user.

\img{\IV}{SI_DATA_C.png}{Complete data definition}{SI_DATA_C}

The form layout definition of the Java object is depicted on the \figref{SI_FORM}. 

\img{\IV}{SI_FORM.png}{UML object diagram for form layout definition}{SI_FORM}

\subsection{Study Design Execution} \label{43}


The entry form for study design execution has as well the hierarchical layout like the one for skeletal inventories, but there are additionally two elements on the main form. The first is the selector from skeletal inventories. It plays a role by the selection of the bone organs as input for the assays. To each assay a set bone segment types is defined in the extensions, that can be can be assigned to them as input. These bone on this form are not created newly but existing ones are selected, that were already added in the frame of the skeletal inventory data input.  However there can be a large amount bone segments stored in the system, and thus the search is facilitated by showing only the ones that belong to the preselected skeletal inventory. The second is a global label field, whose value will be the label of all newly created instances.




\img{\IV}{SDE_UI.png}{Input form for study design execution}{SDE_UI}

Moreover the bone segment selector is not just a HTML selector input field, but a floating window implemented by JavaScript that allows the convenient browsing (\figref{SDE_SI}). It has two advantage with respect to the conventional selector. Firstly it allows to display additional information about the instances above their labels, like their types or longer descriptions. Secondly it does not loads the form layout with additional subform for the selected instances, which by large amount assays and measurement datums is an important aspect.

\img{\IV}{SDE_IS.png}{Instance selector for existing bone segment}{SDE_SI}


On \figref{SDE_SI} can be seen that the there are two section, one for the selected instances, and one for the instances to select. 


The complete data structure of the form can be seen on the following image.

\img{\IV}{SDE_DATA_C.png}{Complete data model}{SDE_DATA_C}


