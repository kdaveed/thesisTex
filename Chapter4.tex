\chapter{Implementation}


\section{Web application ontology}


\subsection{Introduction}

\begin{itemize}
	\item Computer programs are able to overtake exercise from humans to accelerate work. In this case work we want speed up is the application development. 
\end{itemize}

\img{\IVI}{basicFlow.png}{Basic workflow}

\begin{itemize}
	\item  For example we have the form definition.
\end{itemize}


\begin{lstlisting}[language=html, basicstyle=\footnotesize]
<form action="http://example.org/newUser">
   	Username <input type="text" name="userName"></br>
	Password <input type="text" name="password"></br>
	<input type="submit">Submit</input>
</form>
\end{lstlisting}

\itemI{Let the developer concentrate on the meaningful parts.}

\begin{lstlisting}[basicstyle=\footnotesize]
{
  type : "form",
  action : "http://example.org/newUser",
  elements : [
    { type : "text", text : "Username", varName : "userName"},
    { type : "text", text : "Password", varName : "password"}
  ]
}
\end{lstlisting}

\img{\IVI}{frameworkFunc.png}{Framework functionality}



\itemI{The goal is store the configuration of the web application persistently in a database. In our case the goal is to store the data in RDF data.}

\subsection{Form definition}

\img{\IVI}{ontologyForm.png}{Web application ontology for the form}

\itemI{Explanation of the main elements and their functionality}

\itemII{Next that each form element has to represent a variable.  This is denoted with blue the wa:Variable. And the variable name from Image X. is taken by variable instance, which is represented by the form}{Here is important to explain the difference between the wa:SubFormAdder and its two subclasses, wa:ClassSelectorSubformAdder, and wa:InstanceSelectorSubformAdder. }

\img{\IVI}{difference.png}{Difference between sub form adders}

\itemI{min, max cardinality will be here addressed}

\img{\IVI}{formDescRDF.png}{Form descriptor RDF Data}





\subsection{Data definition}

\img{\IVI}{statement.png}{Statement in RDF Vocabulary}

\img{\IVI}{coreOntology.png}{Core ontology}

\img{\IVI}{variableTypes.png}{Variable types}

\img{\IVI}{ontologyStatement.png}{Statement types and attributes}

\img{\IVI}{tripleSet1.png}{Statement configuration dataset I}

\img{\IVI}{tripleSet2.png}{Statement configuration dataset II.}

\img{\IVI}{formDefinition1.png}{Statement definition I}

\subsection{VIVO adoption}

\itemI{As it was described in the previous section in VIVO each custom entry form is called by an HTTP request that contains three parameters: subjectUri, predicateUri and objectUri.}

\img{\IVI}{base.png}{Base definition of the data input process}

\itemI{So the key point is that the data input process instances can be queried by the property coming with the request.}

\section{Server-side implementation}


\subsection{Overview}


\img{\IVII}{overview.png}{Overview of the mechanism on the server}

\itemI{In the following chapters the problems and their modeling which were discussed in the previous chapters will be investigated in a bit more detail by explaining the solution for them}

\subsection{Form representation in Java}

\img{\IVII}{uml1.png}{UML Diagram of the classes for the form}

Two routines :
\itemII{One SPARQL for literals}{And one for the initialization of the elements which returns a list of uris and types.}

\img{\IVII}{rdfToJava.png}{From RDF to Java}

\itemI{The literal fields asks for the type of the variable it represents and the type of the descriptor will be based on this literal field.}

\img{\IVII}{formDescriptor.png}{Form descriptor JSON object}

\subsection{Data model in Java}

\itemII{Querying the configuration triples regarding statements}{Processing into the tree structured graph model}

\img{\IVII}{graphUML.png}{Graph UML}

Validation

\itemIII{Data dependencies can be over graphs}{But graphs can be connected only through multi statements}{The graph has to be a tree. There are no use cases right now where any loop would be required}

\img{\IVII}{jsonVSGraph.png}{JSON vs graph model}

\itemII{Data saving mechanism explanation}{Data retrieval mechanism explanation}

\subsection{Data Dependencies}


•	The data dependencies are important only for the form. 
•	Everything starts with the form descriptor.
•	There are cases where from the main form no element appears on the form.
•	A have to bring examples to some problems that illustrate the problem.
•	Here comes at first the ontology awareness into question.

\img{\IVII}{exampleProblem.png}{Example problem}

where,

\img{\IVII}{explanation.png}{Elements of the simplified notation}

\img{\IVII}{restrictionDirection.png}{Two restriction directions}

•	Post processing for different restriction types

\img{\IVII}{variableDependency.png}{Getting dependent data}

\subsection{Editing and deleting data}

•	This feature was not introduced on the overview image but it is really important.

\img{\IVII}{edit.png}{Difference between the submissions and edit data on the form}


\subsection{Navigator}

\img{\IVII}{selectorVsFormGraph.png}{Selector VS form graph}

•	Goal is to display more information about instances to select in order to facilitate their finding
•	By such advanced window it possible to offer filter options and loading the subset of the instances by introducing LIMIT on the SPARQL query. It could make the page more efficient
•	But such element requires JavaScript code which could become complex
•	Even if we need to offer some Navigator featured introduced in Section 3.2.3


\img{\IVII}{navigatorClassDiagram.png}{Navigator class diagram}

•	Example with RDF data configuration and routine for 

