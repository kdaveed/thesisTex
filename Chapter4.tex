\chapter{Vocabulary for web application domain}

The aim of this chapter is show how can different data input problems expressed through the instantiation of the designed set of Java classes. At first the elements of the vocabulary is discussed briefly, then the solved two use-cases of the RDFBones project. 

\section{Elements of the vocabulary}

\subsection{Data definitions}

The first part of the vocabulary relates to the RDF data definition. The two main classes for this purpose are \textit{Triple} and the \textit{RDFNode}. Both of them have different subclasses for the custom cases. \figref{voc1} shows UML class diagram for the different types of node, and \figref{voc2} in turn depicts the classes for the triples.

\img{\IV}{voc1.png}{Java classes for RDF nodes}{voc1}

The class diagram does not contain all the fields and methods for the sake of simplicity. The most important field is the \textit{variableName}, based on which the form elements can reference the nodes. In the data definition constant classes can appear, for this stands the class \textit{Constant}. In the vocabulary there are two specific classes for the input nodes. The first is the \textit{MainInputNode}, which is used for the variables, that are coming with initial form call. In VIVO these are always the \textit{subjectUri}, the \textit{predicateUri} and the \textit{rangeUri}. The class \textit{FormInputNodes} in turn stands for the variables that appear on the form.

\img{\IV}{voc2.png}{Java classes for RDF triples}{voc2}

In the class \textit{Triple} the three most relevant fields are the \textit{subject}, \textit{object} and \textit{predicate}. The first two have the type \textit{RDFNode}, while the predicate is always a constant string. The class \textit{MultiTriple}, were already discussed in the previous chapter. The \textit{LiteralTriple} plays only a role in the advance instance selector interface, because currently the system is not capable of creating literal triple above the labels of the instances. There are two types of restriction triple, one for the classes, the class \textit{RestrictionTriple}, and the other for the instances, the class (\texit{InstanceRestriction}.








\subsection{Form definition}

\img{\IV}{voc3.png}{Java classes for the form}{voc3}

\img{\IV}{voc4.png}{Java classes for instance viewer}{voc4}

\section{Use-cases of the \textit{RDFBones} project}

The aim of this section is to show how it is possible to solve different problems with designed vocabulary. It covers the two main tasks of the project, the skeletal inventories and the study design execution. These two examples are sufficient to show the utility of the particular elements in the vocabulary and exemplify how their assembly can lead to a compact definition of complex web application problems.

\subsection{Skeletal Inventories}

Skeletal inventories were already addressed in section \ref{[331]}. Their goal is to define what kind of skeletal elements are present. In this part the creation of the primary skeletal inventories are discussed in more detail. This use-case addresses some additional challenges of the software, that were not mentioned yet.
The explanation starts with the illustration of the implemented interface, to show what problem the high level logic has to define. As it was mentioned in figure \ref{411_1}, the entry forms can have inputs, which in this case the input is the class URI of the skeletal subdivision that has to be added with it sub subdivisions and bone organs. Therefore the first element of the entry form is the selector of the sub subdivision.


\img{\IV}{SI_UI.png}{Input form for skeletal inventories}{SI_UI}

Next to the selector the buttons \textit{Add} and \textit{Add all} can be seen, that let the user add the sub forms. \figref{SI_UI} shows the layout, when two sub sudivision were added, to each of them, a bone organ. The bone organ selector works exactly the same as the sub sudvision selector, but the selector for the completeness state is simple selector, without a sub form. 

\figref{SI_UI} shows the triple scheme representing the skeletal inventories, where the nodes are representing variables. All the rectangle are representing instances. All of them will be newly created instead of the subjectUri, which comes as a main input, and the arrows with double line depicts the multi triples. Important to note that between the variable \textit{boneOrgan} and \textit{boneSegment} there is only a single triple (\textit{fma:regional\_part\_of}) because in this use-case is simplified version and only entire bone segments will be added. 

\img{\IV}{SI_DATA.png}{Skeletal inventory data triples}{SI_DATA}



Above the instances to be created the classes have to be represented in the model too, because they can be the subjects of the class restriction triples.
 Figure \figref{SI_DATA_C} is depicts the complete data model of the problem.

\img{\IV}{SI_DATA_C.png}{Complete data definition}{SI_DATA_C}

For the better readability the predicates are not denoted, but their value can be found in figure \figref{SI_DATA}. Each instance (rectangles) is connected to the class variable (ellipses). The red dotted arrows indicates restriction statements. The large three rectangles, that encompass set of triples are the graph, which are connecting to each other by means of multi triples. This is the structure which is followed by the form as well.

\img{\IV}{SI_FORM.png}{Form layout definition}{SI_FORM}



Above the auxililiary rectangles for the graph,the nodes are colored to indicate their role in the process. The information that the colors hold is not defined in the vocabulary but it can be inferred from the whole data and form model. The first rule is that the main input nodes (\textit{subjectUri} and \textit{rangeUri}) are denoted with red, while the variables appear on the interface are light red. Base on that information is it already possible to determine to which instances it is required to assign an unused URI. Those instance are denoted with yellow.
Furthermore there are two classes in the data model that do not appear on the interface, but their values can be evaluated through SPARQL queries. These are denoted with blue. And the classes with without color, do not appear on the final dataset, but they indicates constraint on the existing instances.
Finally \figref{SI_FORM} display the configuration data describing the form structure. 


\subsection{Study Design Execution}


The entry form for study design execution has as well the hierarchical layout like the one for skeletal inventories, but there are additionally two elements on the main form. The first is the selector from skeletal inventories. It plays a role by the selection of the bone organs as input for the assays. To each assay a set bone segment types is defined in the extensions, that can be can be assigned to them as input. These bone on this form are not created newly but existing ones are selected, that were already added in the frame of the skeletal inventory data input.  However there can be a large amount bone segments stored in the system, and thus the search is facilitated by showing only the ones that belong to the preselected skeletal inventory. The second is a global label field, whose value will be the label of all newly created instances.




\img{\IV}{SDE_UI.png}{Input form for study design execution}{SDE_UI}

Moreover the bone segment selector is not just a HTML selector input field, but a floating window implemented by JavaScript that allows the convenient browsing (\figref{SDE_SI}). It has two advantage with respect to the conventional selector. Firstly it allows to display additional information about the instances above their labels, like their types or longer descriptions. Secondly it does not loads the form layout with additional subform for the selected instances, which by large amount assays and measurement datums is an important aspect.

\img{\IV}{SDE_IS.png}{Instance selector for existing bone segment}{SDE_SI}


On \figref{SDE_SI} can be seen that the there are two section, one for the selected instances, and one for the instances to select. 


The complete data structure of the form can be seen on the following image.

\img{\IV}{SDE_DATA_C.png}{Complete data model}{SDE_DATA_C}


