\chapter{Vocabulary for RDF data input}

The aim of this chapter is show how can different data input problems be expressed through the instantiation of specific set of Java classes. At first the elements of the vocabulary is discussed briefly, then the solved two use-cases of the RDFBones project are presented.

\section{Elements of the vocabulary}

\subsection{Data definitions}

The first part of the vocabulary relates to the RDF data definition. The two main classes for this purpose are the \textit{Triple} and the \textit{RDFNode}. Both of them have different subclasses for the custom cases. \figref{voc1} shows the UML class diagram for the different types of node, and \figref{voc2} in turn depicts the classes for the triples.

\img{\IV}{voc1.png}{Java classes for RDF nodes}{voc1}

The class diagram does not contain all the fields and methods for the sake of simplicity. The most important field is the \textit{variableName}, based on which the form elements can reference the nodes. In the data definition constant classes can appear, for this stands the class \textit{Constant}. In the vocabulary there are two specific classes for the input nodes. The first is the \textit{MainInputNode}, which represent the variables, that are coming with initial form call. In VIVO these are always the \textit{subjectUri}, the \textit{predicateUri} and the \textit{rangeUri}. The class \textit{FormInputNodes} stands for the variables that appear on the form.

\img{\IV}{voc2.png}{Java classes for RDF triples}{voc2}

In the class \textit{Triple}, the three most relevant fields are the \textit{subject}, the \textit{object} and the \textit{predicate}. The first two have the type \textit{RDFNode}, while the predicate is always a constant string. The role of the class \textit{MultiTriple} were already discussed the previous chapter. The \textit{LiteralTriple} plays only a role in the advanced instance selector interface (discussed in more detail later), because currently the system is not capable of creating literal triples above the labels of the instances. There are two types of restriction triple, one for the classes, the class \textit{RestrictionTriple}, and the other for the instances, the class (\textit{InstanceRestrictionTriple}. The usage of the latter will be discussed in section \textit{43}. The former is for the restrictions defined with \textit{owl:someValuesFrom} and \textit{owl:allValuesFrom} properties, while its subclass the \textit{QualifiedRestrictionTriple} represents the qualified restriction triples. The last restriction triple, the \textit{GreedyRestrictionTriple} stands for the cases where the query on the restrictions has to check there are restrictions applied not only directly on the input class, but on its super classes as well.

\subsection{Form definition}

As it was already mentioned in the previous chapter the two main classes for the form layout definition are the \textit{Form} and the \textit{FormElement}. The form has a title as a string and contains the different form elements in its field \textit{formElement}. 

\img{\IV}{voc3.png}{Java classes for the form}{voc3}

In the class \textit{FormElement} the most important field is the dataKey, which is holds the variable name for the RDF node it represents. The form element \textit{SubFormAdder} has a field \textit{Form}, which allows the sub form definition. The class \textit{LiteralField} stands for an element, which allows to define the prefix for the labels of all instances created newly through the data input process. Here it is important to note that on the forms implemented for the project, it has to be possible to let the user selecting existing instances, which will contribute to the resulting dataset. The class \textit{Selector} stands for the HTML selector element, which allows the definition selection both of instances and classes on the form. The class \textit{InstanceSelector} denotes a such field where the existing instance can be selected through a floating window implemented in JavaScript. This window allows tp display more information, by displaying the instances within a table where the different columns contains data about them. This table, its cells and triples for the additional SPARQL query by the classes depicted on \figref{voc4}. Finally, the class \textit{AuxNodeSelector}, allows the selection of such instances on the form, who does not contribute to the resulting dataset, just they help to filter the instance for the other instance selectors.

\img{\IV}{voc4.png}{Java classes for instance viewer}{voc4}

\section{Use-cases of the \textit{RDFBones} project}

This section covers the two main tasks of the project, the primary skeletal inventories and the study design execution. These two examples are sufficient to demonstrate the utility of the particular elements in the vocabulary and exemplify how their assembly can lead to a compact definition of complex web application problems. 

\subsection{Primary Skeletal Inventory}

Skeletal inventories were already addressed in section \ref{rdfbones}. To be able understand the software specification of the data input form, it is inevitable to go a bit more into the details of extensions of the \textit{RDFBones} project. The primary skeletal inventory is the main extension, and has the peculiarity that it does not contain any custom bone segments, but refers all of them as entire bones. For this purpose there is a class called \textit{EntireBoneOrgan}, which has as many subclasses for the particular bones as many bone organ classes have been taken from the FMA ontology. The entire bones are connected to the bone organs through restriction on the property \textit{fma:regional\_part\_of}. Moreover for each entire bone organ a custom completeness datum class is created, which acts as connector between the primary skeletal inventory class and the entire bone classes as well by means of restrictions. 

\img{\IV}{useCase1.png}{Primary skeletal inventory extension}{primSkelInv}

\figref{primSkelInv} depicts the scheme of the primary skeletal inventory extension. The \textit{X} and \textit{Y} represent the different bone organs classes as examples, and \textit{E.B.O.} is the abbreviation for entire bone organ, while \textit{C2S} stands for completeness two states. Important to note that the class \textit{CompletenessTwoStatesLabel} has two instances, which are the part of the extension too, and will appear in all skeletal inventory dataset.

The most important skeletal region in the Biological Anthropology Department is the skull, so in the following the data input for the skull will be discussed. The skull does not consist directly of bone organs, but of two sub two sub subdivisions, so a primary skeletal inventory for a skull is represented with the following triple pattern: 

\img{\IV}{SI_DATA.png}{Skeletal inventory data triples}{SI_DATA}

The classes of the pattern are not shown, because the main scope of the image is to illustrate the necessity of the single and multi triples in the definition. As it was addressed, the subdivision (in our case skull) consists of multiple sub subdivision, where all consist of multiple bone organs. However each bone organ has only one bone segment (the entire), and one categorical measurement datum and category label, and belongs to one skeletal inventory. The skeletal inventory is represented by the \textit{subjectUri} variable, because the entry form is called from its profile page.

Before showing how the use-case is defined by the descriptor instances, the implemented interface is discussed (\figref{SI_UI}). Under the title of the form, a sub form adder element appears. This element is implemented in a way that it incorporates a class selector as well. This is the same if the sub form would contain a type selector, just the form layout is more compact. It can be seen the added sub form has a title, which the label of the added class for the element. The sub form adder for the bone organs is the same. The sub form for the particular bone organs contains the selector through which the user can select if the bone is complete or partly present in the given skull.

\img{\IV}{SI_UI.png}{Generated interface for primary skeletal inventory}{SI_UI}

\figref{SI_DATA_C} depicts the complete data definition with the triples and the nodes. For the better readability the predicates are not denoted, but their value can be found in figure \figref{SI_DATA}. The predicate is always \textit{rdf:type} where the subject is an instance and the object is a class. The three rectangles denotes the three subgraphs of the graph pattern, divided by the multi triples. The pattern contains the two main input nodes (red - subjectUri, rangeUri) and three form input nodes (light red - subSubDivisionType, boneOrganType, categoryLabel). The instances without coloring are normal \textit{RDFNode} instances in the descriptor dataset, and as they do not appear on the form, they will get a new unused IRI after the submission. The class input nodes get their values based on the SPARQL queries generated from the restriction triples. The classes comepleteness2StatesType and boneSegmentType are special because their value will be evaluated after the submission based on the value of the boneOrganType node. In this way that the interface hides the complexity of the underlying data model from the user.

\img{\IV}{SI_DATA_C.png}{Complete data definition}{SI_DATA_C}

The form layout definition of the Java object is depicted on the \figref{SI_FORM}. It can be seen that it reflects the hierarchy of the form, and the form elements refer to the variable names of the nodes in the graph pattern.

\img{\IV}{SI_FORM.png}{UML object diagram for form layout definition}{SI_FORM}

\subsection{Study Design Execution} \label{43}

The title of the section indicates a class from the OBI ontology. A study design execution is a part of an investigation and consists of several different assays. Assay is a process for assessing a certain quality of a given object. In our case the input objects are bone segments, and the outputs are information content entities. For example an investigation aiming to estimate the gender of an individual, takes different tokens on particular skeleton, and defines how masculine or feminine they are, and at the end aggregates the values. \figref{glab} illustrates an example, the token glabella on the frontal bone, and its expressions grouped into five categories.

\img{\IV}{glabExpressions.png}{Glabella and its expressions}{glab}

The ontology extensions describing such investigations contains all assays as different OWL classes. The assays are connected with restrictions to specific bone segment and information content entity classes. Since the output data of the assay have to be in chosen from a given set, the extensions contains instances just like by the skeletal inventory the two types of completeness state. \figref{sdeExt} depict the subset of the RDFBones ontology extension for gender estimation, where the expression are represented by the instances of the class \textit{GenderScore}.

\img{\IV}{sdeExt.png}{RDFBones extension for study design execution}{sdeExt}

The graph pattern of a study design execution can be seen on \figref{sdeDataScheme}. During the execution of one assay, only the assay and the gender score instances will be newly created, because the bone segment are already added to the system through skeletal inventories, and the gender scores are given.

\img{\IV}{sdeDataScheme.png}{Input form for study design execution}{sdeDataScheme}

\figref{SDE_UI} shows the implemented interface for the data entry, which is called from the profile page of the investigation instance. The two first elements are additional with respect to the interface discussed in the previous section. The first is an auxiliary node selector, whose purpose is to help the user in finding the input bone segments by selecting the skeletal inventory they belong to. The second is a literal field for setting the prefix for the label of the newly created instances, which facilitates later the identification of the performed assays.

\img{\IV}{SDE_UI.png}{Input form for study design execution}{SDE_UI}

The interface allows to add multiple measurements, but in our case only the gender score (sex score) is defined in the extension, but there may be such advanced assays which have multiple output data. The bone segment is an instance selector, where the grey button with the \textit{Select} label opens the floating window for more elaborate instance selection (\figref{SDE_SI}). Such window allows the selection of multiple instances, which is necessary because there are such tokens, which refers two multiple bone segments at the same time.

\img{\IV}{SDE_IS.png}{Instance selector for existing bone segment}{SDE_SI}

The complete RDF graph pattern can be seen on \figref{SDE_DATA_C}, where the green nodes are the constants, and the dotted red arrows are instance restriction triples. The framework knows that the instances which are connected with instance restriction triples, are not part of the created data. The interface description works same way as by the skeletal inventories through Java objects.

\img{\IV}{SDE_DATA_C.png}{Complete data model}{SDE_DATA_C}

The two discussed use-cases showed that the form scheme is defined by the designed vocubulary, which representation of the extension scheme. So the designed system offers a language to build web application rapidly on the top of different ontology extension schemes.

\img{\IV}{schemes.png}{Extension schemes of the discussed use cases}{schemes}

